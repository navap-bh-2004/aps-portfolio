<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>APS DSA-Use Cases</title>
    <link rel="stylesheet" href="./style5.css" />
    <link rel="stylesheet" href="./styles/case-study-1.css" />
    <link
      href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"
    />
    <style>
      :root {
        --amazon-orange: #ff9900;
        --amazon-dark-blue: #232f3e;
        --amazon-light-blue: #37475a;
        --amazon-teal: #00a8e1;
        --amazon-gray: #eaeded;
        --amazon-dark-gray: #444;
        --amazon-light-gray: #f5f5f5;
        --white: #ffffff;
        --shadow-light: 0 5px 15px rgba(0, 0, 0, 0.05);
        --shadow-medium: 0 8px 30px rgba(0, 0, 0, 0.12);
        --shadow-dark: 0 10px 40px rgba(0, 0, 0, 0.2);
        --border-radius: 8px;
        --transition-speed: 0.3s ease;
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Poppins", sans-serif;
        line-height: 1.6;
        color: var(--amazon-dark-gray);
        background-color: var(--white);
      }

      .container {
        margin: 0 auto;
        padding: 0 20px;
      }

      /* Algorithm Case Study Section */
      .algorithm-case-study {
        padding: 80px 0;
        background: linear-gradient(120deg, #f8f9fa, #f0f2f5);
      }

      .case-study-header {
        text-align: center;
        margin-bottom: 60px;
      }

      .case-study-subtitle {
        color: var(--amazon-orange);
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 1.5px;
        margin-bottom: 10px;
        font-size: 0.9rem;
      }

      .case-study-title {
        color: var(--amazon-dark-blue);
        font-size: 2.5rem;
        margin-bottom: 20px;
        position: relative;
        display: inline-block;
      }

      .case-study-title::after {
        content: "";
        position: absolute;
        bottom: -10px;
        left: 50%;
        transform: translateX(-50%);
        width: 80px;
        height: 3px;
        background: var(--amazon-orange);
        border-radius: 3px;
      }

      .case-study-intro {
        max-width: 700px;
        margin: 0 auto;
        font-size: 1.1rem;
        color: var(--amazon-light-blue);
      }

      .algorithm-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 40px;
        margin-top: 50px;
      }

      .algorithm-explanation {
        background: var(--white);
        border-radius: var(--border-radius);
        padding: 40px;
        box-shadow: var(--shadow-medium);
        position: relative;
        overflow: hidden;
      }

      .algorithm-explanation h3 {
        color: var(--amazon-dark-blue);
        margin-bottom: 20px;
        font-size: 1.5rem;
      }

      .algorithm-explanation p {
        margin-bottom: 15px;
        font-size: 1rem;
      }

      .algorithm-steps {
        margin-top: 30px;
      }

      .algorithm-steps h4 {
        color: var(--amazon-orange);
        margin-bottom: 15px;
        font-size: 1.2rem;
      }

      .algorithm-steps ol {
        padding-left: 20px;
        margin-bottom: 20px;
      }

      .algorithm-steps li {
        margin-bottom: 10px;
      }

      .amazon-applications {
        background: var(--amazon-dark-blue);
        color: var(--white);
        border-radius: var(--border-radius);
        padding: 40px;
        box-shadow: var(--shadow-medium);
        display: flex;
        flex-direction: column;
      }

      .amazon-applications h3 {
        color: var(--amazon-orange);
        margin-bottom: 20px;
        font-size: 1.5rem;
      }

      .application-card {
        background: rgba(255, 255, 255, 0.1);
        border-radius: var(--border-radius);
        padding: 20px;
        margin-bottom: 20px;
        transition: all var(--transition-speed);
        border-left: 3px solid var(--amazon-orange);
      }

      .application-card:hover {
        transform: translateY(-5px);
        background: rgba(255, 255, 255, 0.15);
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
      }

      .application-card h4 {
        color: var(--amazon-orange);
        margin-bottom: 10px;
        display: flex;
        align-items: center;
      }

      .application-card h4 i {
        margin-right: 10px;
      }

      .application-card p {
        margin-bottom: 15px;
        font-size: 0.95rem;
        color: #e0e0e0;
      }

      .efficiency-metrics {
        margin-top: 30px;
        background: rgba(255, 153, 0, 0.1);
        padding: 20px;
        border-radius: var(--border-radius);
      }

      .efficiency-metrics h4 {
        color: var(--amazon-orange);
        margin-bottom: 15px;
        font-size: 1.2rem;
      }

      .metrics-grid {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 15px;
      }

      .metric-card {
        background: var(--white);
        padding: 15px;
        border-radius: var(--border-radius);
        text-align: center;
        box-shadow: var(--shadow-light);
      }

      .metric-card h5 {
        color: var(--amazon-dark-blue);
        font-size: 1rem;
        margin-bottom: 5px;
      }

      .metric-value {
        color: var(--amazon-orange);
        font-size: 1.8rem;
        font-weight: 700;
        margin-bottom: 5px;
      }

      .metric-description {
        font-size: 0.8rem;
        color: var(--amazon-dark-gray);
      }

      .code-snippet {
        margin: 0;
        background: #2d2d2d;
        border-radius: var(--border-radius);
        padding: 20px;
        overflow-x: auto;
      }

      .code-snippet pre {
        font-family: "Consolas", monospace;
        color: #e0e0e0;
        font-size: 0.9rem;
      }

      .code-snippet code .comment {
        color: #6a9955;
      }

      .code-snippet code .keyword {
        color: #569cd6;
      }

      .code-snippet code .function {
        color: #dcdcaa;
      }

      .code-snippet code .string {
        color: #ce9178;
      }

      .relationship-diagram {
        position: relative;
        margin-top: 40px;
      }

      .relationship-diagram h4 {
        color: var(--white);
        margin-bottom: 15px;
        font-size: 1.2rem;
        text-align: center;
      }

      .diagram-container {
        background: rgba(255, 255, 255, 0.1);
        border-radius: var(--border-radius);
        padding: 20px;
        display: flex;
        justify-content: center;
        position: relative;
        min-height: 200px;
      }

      .entity {
        position: absolute;
        width: 100px;
        height: 100px;
        background: var(--white);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 600;
        box-shadow: var(--shadow-medium);
        z-index: 2;
      }

      .entity-a {
        top: 20px;
        left: 20%;
        background: rgba(255, 153, 0, 0.2);
        border: 2px solid var(--amazon-orange);
        color: var(--amazon-dark-blue);
      }

      .entity-b {
        top: 20px;
        right: 20%;
        background: rgba(35, 47, 62, 0.2);
        border: 2px solid var(--amazon-dark-blue);
        color: var(--amazon-dark-blue);
      }

      .entity-arrows {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 1;
      }

      @media (max-width: 768px) {
        .algorithm-grid {
          grid-template-columns: 1fr;
        }

        .metrics-grid {
          grid-template-columns: 1fr;
        }

        .case-study-title {
          font-size: 2rem;
        }

        .case-study-intro {
          font-size: 1rem;
        }
      }
    </style>
  </head>

  <body>
    <!---------------------- Case Styudy 1 Stable Matching Problem  ----------------------------- -->

    <section class="algorithm-case-study">
      <div class="container">
        <div class="case-study-header">
          <p class="case-study-subtitle">Algorithm Analysis</p>
          <h2 class="case-study-title">Efficient Allocation of Resources</h2>
          <p class="case-study-intro">
            Exploring how the Gale-Shapley algorithm for stable matching
            optimizes resource allocation and pairing in Amazon's vast ecosystem
            of products, services, and logistics.
          </p>
        </div>

        <div class="algorithm-grid">
          <div class="algorithm-explanation">
            <h3>Understanding the Stable Matching Algorithm</h3>
            <p>
              The Stable Matching Problem is a fundamental algorithm in
              combinatorial optimization that addresses the challenge of finding
              a stable matching between two equally sized sets of elements, each
              with their own preferences.
            </p>
            <p>
              A matching is considered "stable" when there are no two elements
              that would prefer each other over their current partners.
            </p>

            <div class="algorithm-steps">
              <h4>Key Steps of the Algorithm:</h4>
              <ol>
                <li>Initialize all participants as free (unmatched)</li>
                <li>
                  While there exists a free proposer who hasn't proposed to
                  every receiver:
                  <ul>
                    <li>Choose such a free proposer</li>
                    <li>
                      Have them propose to their highest-ranked receiver who
                      hasn't yet rejected them
                    </li>
                  </ul>
                </li>
                <li>
                  If the receiver is free, they provisionally accept the
                  proposal
                </li>
                <li>
                  If the receiver is already engaged, they compare the new
                  proposer with their current partner:
                  <ul>
                    <li>
                      If they prefer the new proposer, they accept the new
                      proposal and release the previous partner
                    </li>
                    <li>Otherwise, they reject the new proposal</li>
                  </ul>
                </li>
                <li>
                  When no free proposers remain, the algorithm terminates with a
                  stable matching
                </li>
              </ol>
            </div>

            <div class="code-snippet">
              <pre><code><span class="comment">// C++ implementation of the Gale-Shapley algorithm</span>
<span class="keyword">#include</span> <span class="string">&lt;iostream&gt;</span>
<span class="keyword">#include</span> <span class="string">&lt;vector&gt;</span>
<span class="keyword">#include</span> <span class="string">&lt;unordered_map&gt;</span>
<span class="keyword">#include</span> <span class="string">&lt;queue&gt;</span>

<span class="keyword">class</span> <span class="function">StableMatching</span> {
<span class="keyword">private</span>:
    <span class="keyword">std</span>::vector&lt;std::vector&lt;<span class="keyword">int</span>&gt;&gt; proposerPrefs;
    <span class="keyword">std</span>::vector&lt;std::vector&lt;<span class="keyword">int</span>&gt;&gt; receiverPrefs;
    <span class="keyword">std</span>::vector&lt;std::vector&lt;<span class="keyword">int</span>&gt;&gt; receiverRanking;
    <span class="keyword">int</span> n;  <span class="comment">// number of elements in each set</span>

<span class="keyword">public</span>:
    StableMatching(<span class="keyword">const</span> std::vector&lt;std::vector&lt;<span class="keyword">int</span>&gt;&gt;& propPrefs, 
                   <span class="keyword">const</span> std::vector&lt;std::vector&lt;<span class="keyword">int</span>&gt;&gt;& recvPrefs) {
        proposerPrefs = propPrefs;
        receiverPrefs = recvPrefs;
        n = proposerPrefs.size();
        
        <span class="comment">// Precompute rankings for O(1) preference comparisons</span>
        receiverRanking.resize(n, std::vector&lt;<span class="keyword">int</span>&gt;(n));
        <span class="keyword">for</span> (<span class="keyword">int</span> i = 0; i < n; i++) {
            <span class="keyword">for</span> (<span class="keyword">int</span> j = 0; j < n; j++) {
                receiverRanking[i][receiverPrefs[i][j]] = j;
            }
        }
    }

    std::vector&lt;<span class="keyword">int</span>&gt; <span class="function">findStableMatching</span>() {
        std::vector&lt;<span class="keyword">int</span>&gt; matches(n, -1);  <span class="comment">// Stores receiver->proposer matches</span>
        std::vector&lt;<span class="keyword">int</span>&gt; nextProposal(n, 0);  <span class="comment">// Next preference to propose to</span>
        std::queue&lt;<span class="keyword">int</span>&gt; freeProposers;
        
        <span class="comment">// Initially, all proposers are free</span>
        <span class="keyword">for</span> (<span class="keyword">int</span> i = 0; i < n; i++) {
            freeProposers.push(i);
        }
        
        <span class="comment">// While there are free proposers</span>
        <span class="keyword">while</span> (!freeProposers.empty()) {
            <span class="keyword">int</span> proposer = freeProposers.front();
            freeProposers.pop();
            
            <span class="comment">// Get next preferred receiver for this proposer</span>
            <span class="keyword">int</span> receiver = proposerPrefs[proposer][nextProposal[proposer]++];
            
            <span class="comment">// If receiver is free, match them</span>
            <span class="keyword">if</span> (matches[receiver] == -1) {
                matches[receiver] = proposer;
            } 
            <span class="comment">// If receiver prefers new proposer over current match</span>
            <span class="keyword">else if</span> (receiverRanking[receiver][proposer] < 
                       receiverRanking[receiver][matches[receiver]]) {
                <span class="comment">// Current match becomes free again</span>
                freeProposers.push(matches[receiver]);
                matches[receiver] = proposer;
            } 
            <span class="comment">// If receiver rejects, proposer remains free</span>
            <span class="keyword">else</span> {
                freeProposers.push(proposer);
            }
        }
        
        <span class="keyword">return</span> matches;
    }
};</code></pre>
            </div>
          </div>

          <div class="amazon-applications">
            <h3>Applications in Amazon's Ecosystem</h3>

            <div class="application-card">
              <h4>
                <i class="fas fa-truck-loading"></i> Warehouse-Product
                Assignment
              </h4>
              <p>
                Amazon uses stable matching principles to optimize the
                assignment of products to warehouse locations based on complex
                variables:
              </p>
              <ul>
                <li>
                  Products "prefer" warehouses based on proximity to frequent
                  delivery locations
                </li>
                <li>
                  Warehouses "prefer" products based on storage efficiency,
                  demand patterns, and regional popularity
                </li>
                <li>
                  The stable matching ensures optimal inventory distribution
                  across Amazon's vast fulfillment network
                </li>
              </ul>
            </div>

            <div class="application-card">
              <h4><i class="fas fa-users"></i> AWS Resource Allocation</h4>
              <p>
                Amazon Web Services applies stable matching concepts for cloud
                resource allocation:
              </p>
              <ul>
                <li>
                  Customer workloads "prefer" certain server types based on
                  computational needs
                </li>
                <li>
                  Server clusters "prefer" certain workloads based on resource
                  utilization patterns
                </li>
                <li>
                  The resulting stable allocation maximizes infrastructure
                  efficiency while meeting SLAs
                </li>
              </ul>
            </div>

            <div class="relationship-diagram">
              <h4>Stable Matching Relationships</h4>
              <div class="diagram-container">
                <div class="entity entity-a">Set A<br />(Proposers)</div>
                <div class="entity entity-b">Set B<br />(Receivers)</div>
                <svg
                  class="entity-arrows"
                  viewBox="0 0 400 150"
                  xmlns="http://www.w3.org/2000/svg"
                >
                  <path
                    d="M120,70 C180,30 220,30 280,70"
                    stroke="#FF9900"
                    stroke-width="2"
                    fill="none"
                    stroke-dasharray="5,5"
                  />
                  <path
                    d="M280,80 C220,120 180,120 120,80"
                    stroke="#232F3E"
                    stroke-width="2"
                    fill="none"
                  />
                </svg>
              </div>
            </div>

            <div class="efficiency-metrics">
              <h4>Algorithm Efficiency Impact</h4>
              <div class="metrics-grid">
                <div class="metric-card">
                  <h5>Time Complexity</h5>
                  <div class="metric-value">O(n²)</div>
                  <p class="metric-description">
                    Where n is the number of participants in each set
                  </p>
                </div>
                <div class="metric-card">
                  <h5>Warehouse Efficiency</h5>
                  <div class="metric-value">+24%</div>
                  <p class="metric-description">
                    Improvement in storage utilization
                  </p>
                </div>
                <div class="metric-card">
                  <h5>Delivery Optimization</h5>
                  <div class="metric-value">-18%</div>
                  <p class="metric-description">
                    Reduction in delivery time variance
                  </p>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!---------------------- Case Styudy 1 Stable Matching Problem  ----------------------------- -->

    <!---------------------- Case Study 2 Graph Traversal Algorithms ----------------------------- -->
    <section class="algorithm-case-study">
      <div class="container">
        <div class="case-study-header">
          <p class="case-study-subtitle">Algorithm Analysis</p>
          <h2 class="case-study-title">
            Graph Traversal Algorithms: DFS & BFS
          </h2>
          <p class="case-study-intro">
            Exploring how Depth-First Search and Breadth-First Search algorithms
            power critical pathfinding, optimization, and discovery operations
            across Amazon's vast digital and physical infrastructure.
          </p>
        </div>

        <div class="algorithm-grid">
          <div class="algorithm-explanation">
            <h3>Understanding DFS & BFS Algorithms</h3>
            <p>
              Graph traversal algorithms are fundamental to solving complex
              problems involving connected structures. Amazon uses these
              algorithms extensively to optimize operations across its global
              network.
            </p>

            <div class="algorithm-comparison">
              <div class="algorithm-card">
                <h4>Depth-First Search (DFS)</h4>
                <p>
                  DFS explores as far as possible along each branch before
                  backtracking, using a stack data structure (or recursion).
                </p>
                <ul>
                  <li>
                    Explores deep paths fully before exploring alternatives
                  </li>
                  <li>Excellent for maze solving and topological sorting</li>
                  <li>
                    Useful when solutions are likely to be far from the source
                  </li>
                  <li>Memory efficient for deep graphs</li>
                </ul>
              </div>

              <div class="algorithm-card">
                <h4>Breadth-First Search (BFS)</h4>
                <p>
                  BFS explores all neighbors at the present depth before moving
                  to vertices at the next depth level, using a queue data
                  structure.
                </p>
                <ul>
                  <li>Finds shortest paths in unweighted graphs</li>
                  <li>Explores nodes level by level</li>
                  <li>Optimal for finding closest solutions</li>
                  <li>Better for wide, shallow graphs</li>
                </ul>
              </div>
            </div>

            <div class="algorithm-steps">
              <h4>Key Implementation Steps:</h4>
              <div class="steps-grid">
                <div>
                  <h5>DFS Implementation</h5>
                  <ol>
                    <li>Start at a source vertex</li>
                    <li>Mark the current vertex as visited</li>
                    <li>Recursively visit all adjacent unvisited vertices</li>
                    <li>
                      Backtrack when no unvisited adjacent vertices remain
                    </li>
                  </ol>
                </div>

                <div>
                  <h5>BFS Implementation</h5>
                  <ol>
                    <li>Start at a source vertex and mark it as visited</li>
                    <li>Enqueue the source vertex</li>
                    <li>
                      While the queue is not empty:
                      <ul>
                        <li>Dequeue a vertex and process it</li>
                        <li>
                          Enqueue all adjacent unvisited vertices and mark them
                          as visited
                        </li>
                      </ul>
                    </li>
                  </ol>
                </div>
              </div>
            </div>

            <div class="code-snippet">
              <pre><code><span class="comment">// C++ implementations of DFS and BFS</span>
<span class="keyword">#include</span> <span class="string">&lt;iostream&gt;</span>
<span class="keyword">#include</span> <span class="string">&lt;vector&gt;</span>
<span class="keyword">#include</span> <span class="string">&lt;queue&gt;</span>
<span class="keyword">#include</span> <span class="string">&lt;unordered_set&gt;</span>

<span class="keyword">class</span> <span class="function">GraphTraversal</span> {
<span class="keyword">private</span>:
    <span class="keyword">std</span>::vector&lt;std::vector&lt;<span class="keyword">int</span>&gt;&gt; adjacencyList;
    <span class="keyword">int</span> vertices;

<span class="keyword">public</span>:
    GraphTraversal(<span class="keyword">int</span> v) {
        vertices = v;
        adjacencyList.resize(v);
    }

    <span class="keyword">void</span> <span class="function">addEdge</span>(<span class="keyword">int</span> src, <span class="keyword">int</span> dest) {
        adjacencyList[src].push_back(dest);
    }

    <span class="comment">// Depth-First Search implementation</span>
    <span class="keyword">void</span> <span class="function">DFS</span>(<span class="keyword">int</span> startVertex) {
        std::vector&lt;<span class="keyword">bool</span>&gt; visited(vertices, <span class="keyword">false</span>);
        DFSUtil(startVertex, visited);
    }

    <span class="keyword">void</span> <span class="function">DFSUtil</span>(<span class="keyword">int</span> vertex, std::vector&lt;<span class="keyword">bool</span>&gt;& visited) {
        <span class="comment">// Mark current node as visited</span>
        visited[vertex] = <span class="keyword">true</span>;
        std::cout << vertex << " ";

        <span class="comment">// Recursively visit all adjacent vertices</span>
        <span class="keyword">for</span> (<span class="keyword">int</span> adjacent : adjacencyList[vertex]) {
            <span class="keyword">if</span> (!visited[adjacent]) {
                DFSUtil(adjacent, visited);
            }
        }
    }

    <span class="comment">// Breadth-First Search implementation</span>
    <span class="keyword">void</span> <span class="function">BFS</span>(<span class="keyword">int</span> startVertex) {
        <span class="comment">// Mark all vertices as not visited</span>
        std::vector&lt;<span class="keyword">bool</span>&gt; visited(vertices, <span class="keyword">false</span>);
        
        <span class="comment">// Create a queue for BFS</span>
        std::queue&lt;<span class="keyword">int</span>&gt; queue;
        
        <span class="comment">// Mark the current node as visited and enqueue it</span>
        visited[startVertex] = <span class="keyword">true</span>;
        queue.push(startVertex);

        <span class="keyword">while</span> (!queue.empty()) {
            <span class="comment">// Dequeue a vertex and print it</span>
            startVertex = queue.front();
            std::cout << startVertex << " ";
            queue.pop();

            <span class="comment">// Get all adjacent vertices of the dequeued vertex</span>
            <span class="keyword">for</span> (<span class="keyword">int</span> adjacent : adjacencyList[startVertex]) {
                <span class="comment">// If adjacent is not visited, mark it visited and enqueue it</span>
                <span class="keyword">if</span> (!visited[adjacent]) {
                    visited[adjacent] = <span class="keyword">true</span>;
                    queue.push(adjacent);
                }
            }
        }
    }
};</code></pre>
            </div>
          </div>

          <div class="amazon-applications">
            <h3>Applications in Amazon's Ecosystem</h3>

            <div class="application-card">
              <h4>
                <i class="fas fa-box-open"></i> Product Category Navigation
              </h4>
              <p>
                Amazon uses tree traversal algorithms to optimize product
                browsing and search:
              </p>
              <ul>
                <li>
                  <strong>DFS Application:</strong> Generating complete category
                  paths for breadcrumb navigation
                </li>
                <li>
                  <strong>BFS Application:</strong> Finding related products in
                  nearby categories
                </li>
                <li>
                  Enables the hierarchical product categorization structure that
                  helps customers find products efficiently
                </li>
              </ul>
            </div>

            <div class="application-card">
              <h4><i class="fas fa-robot"></i> Warehouse Robotics</h4>
              <p>
                Amazon's automated fulfillment centers rely on graph algorithms
                for robot navigation:
              </p>
              <ul>
                <li>
                  <strong>DFS Application:</strong> Exploring complex shelving
                  arrangements for inventory auditing
                </li>
                <li>
                  <strong>BFS Application:</strong> Finding optimal paths for
                  robots to retrieve items in minimum time
                </li>
                <li>
                  Reduces pick time by up to 50% compared to human-only
                  operations
                </li>
              </ul>
            </div>

            <div class="application-card">
              <h4>
                <i class="fas fa-project-diagram"></i> Supply Chain Optimization
              </h4>
              <p>
                Amazon's global supply chain leverages graph traversal for
                logistics:
              </p>
              <ul>
                <li>
                  <strong>DFS Application:</strong> Detecting cycles in supply
                  dependencies to prevent disruptions
                </li>
                <li>
                  <strong>BFS Application:</strong> Identifying the nearest
                  fulfillment centers to minimize shipping distance
                </li>
                <li>
                  Enables Amazon's promise of fast, reliable delivery across
                  their vast logistics network
                </li>
              </ul>
            </div>

            <div class="application-card">
              <h4><i class="fas fa-thumbs-up"></i> Recommendation Engines</h4>
              <p>Amazon's "Customers who bought this also bought" feature:</p>
              <ul>
                <li>
                  <strong>DFS Application:</strong> Discovering deep niche
                  relationships between products with similar user bases
                </li>
                <li>
                  <strong>BFS Application:</strong> Finding immediately related
                  products for recommendations
                </li>
                <li>
                  Drives up to 35% of Amazon's revenue through intelligent
                  cross-selling
                </li>
              </ul>
            </div>

            <div class="relationship-diagram">
              <h4>Algorithm Comparison</h4>
              <div class="diagram-container">
                <img
                  src="https://github.com/jiyapalrecha35/Google.github.io/blob/main/images/dfs.gif?raw=true"
                  alt="DFS vs BFS Visualization"
                  style="max-width: 100%; height: auto"
                />
              </div>

              <div class="diagram-container">
                <img
                  src="https://github.com/jiyapalrecha35/Google.github.io/blob/main/images/bfs.gif?raw=true"
                  alt="DFS vs BFS Visualization"
                  style="max-width: 100%; height: auto"
                />
              </div>
            </div>

            <div class="efficiency-metrics">
              <h4>Performance Impact at Amazon</h4>
              <div class="metrics-grid">
                <div class="metric-card">
                  <h5>Time Complexity</h5>
                  <div class="metric-value">O(V+E)</div>
                  <p class="metric-description">
                    For both BFS/DFS where V = vertices, E = edges
                  </p>
                </div>
                <div class="metric-card">
                  <h5>Warehouse Robotics</h5>
                  <div class="metric-value">+32%</div>
                  <p class="metric-description">
                    Increase in picking efficiency using BFS pathfinding
                  </p>
                </div>
                <div class="metric-card">
                  <h5>Search Relevance</h5>
                  <div class="metric-value">+27%</div>
                  <p class="metric-description">
                    Improvement in category navigation using hybrid approach
                  </p>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!---------------------- Case Study 2 Graph Traversal Algorithms ----------------------------- -->

    <!---------------------- Case Study 3 A* Algorithm -----------------------------  -->

    <!-- <section class="algorithm-case-study">
      <div class="container">
        <div class="case-study-header">
          <p class="case-study-subtitle">Algorithm Analysis</p>
          <h2 class="case-study-title">A* Algorithm and Best-First Search</h2>
          <p class="case-study-intro">
            Exploring how A* and other heuristic-based search algorithms drive
            intelligent decision-making across Amazon's logistics,
            recommendations, and autonomous systems.
          </p>
        </div>

        <div class="algorithm-grid">
          <div class="algorithm-explanation">
            <h3>Understanding Informed Search Algorithms</h3>
            <p>
              Unlike uninformed search methods like BFS and DFS, informed search
              algorithms leverage additional knowledge (heuristics) about the
              problem domain to find optimal solutions more efficiently. This
              makes them ideal for complex optimization problems across Amazon's
              operations.
            </p>

            <div class="algorithm-comparison">
              <div class="algorithm-card">
                <h4>A* Search Algorithm</h4>
                <p>
                  A* combines the advantages of Dijkstra's algorithm
                  (completeness, optimality) with heuristic approaches
                  (efficiency) to find the shortest path.
                </p>
                <ul>
                  <li>Uses an evaluation function f(n) = g(n) + h(n)</li>
                  <li>g(n): Actual cost from start node to current node</li>
                  <li>h(n): Estimated cost from current node to goal</li>
                  <li>
                    Guarantees optimal path if h(n) is admissible (never
                    overestimates)
                  </li>
                </ul>
              </div>

              <div class="algorithm-card">
                <h4>Best-First Search</h4>
                <p>
                  Prioritizes paths that appear to be leading closer to the
                  goal, making it highly efficient for many problems.
                </p>
                <ul>
                  <li>
                    Uses priority queue based purely on heuristic value h(n)
                  </li>
                  <li>Significantly faster than uninformed search</li>
                  <li>May not always find the optimal solution</li>
                  <li>Excellent for time-sensitive applications</li>
                </ul>
              </div>
            </div>

            <div class="algorithm-steps">
              <h4>Key Implementation Steps of A* Search:</h4>
              <ol>
                <li>Initialize open list with starting node</li>
                <li>Initialize closed list as empty</li>
                <li>
                  While open list is not empty:
                  <ul>
                    <li>
                      Find node with lowest f(n) = g(n) + h(n) in open list
                    </li>
                    <li>
                      If current node is goal, reconstruct and return path
                    </li>
                    <li>Move current node from open list to closed list</li>
                    <li>
                      For each neighbor of current node:
                      <ul>
                        <li>Calculate tentative g score</li>
                        <li>
                          If neighbor is in closed list and new g score is
                          higher, continue
                        </li>
                        <li>
                          If new path is better or neighbor not in open list:
                          <ul>
                            <li>Update g score, f score, and parent pointer</li>
                            <li>
                              Add neighbor to open list if not there already
                            </li>
                          </ul>
                        </li>
                      </ul>
                    </li>
                  </ul>
                </li>
                <li>
                  If open list is empty without finding goal, no path exists
                </li>
              </ol>
            </div>

            <div class="code-snippet">
              <pre><code><span class="comment">// C++ implementation of A* Search Algorithm</span>
<span class="keyword">#include</span> <span class="string">&lt;iostream&gt;</span>
<span class="keyword">#include</span> <span class="string">&lt;vector&gt;</span>
<span class="keyword">#include</span> <span class="string">&lt;queue&gt;</span>
<span class="keyword">#include</span> <span class="string">&lt;unordered_map&gt;</span>
<span class="keyword">#include</span> <span class="string">&lt;cmath&gt;</span>
<span class="keyword">#include</span> <span class="string">&lt;algorithm&gt;</span>

<span class="keyword">struct</span> <span class="function">Node</span> {
    <span class="keyword">int</span> x, y;
    <span class="keyword">double</span> g, h, f;  <span class="comment">// g: cost from start, h: heuristic, f: g+h</span>
    std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; parent;
    
    Node(<span class="keyword">int</span> _x, <span class="keyword">int</span> _y) : x(_x), y(_y), g(0), h(0), f(0), parent({-1, -1}) {}
    
    <span class="keyword">bool</span> <span class="function">operator==</span>(<span class="keyword">const</span> Node& other) <span class="keyword">const</span> {
        <span class="keyword">return</span> x == other.x && y == other.y;
    }
};

<span class="keyword">class</span> <span class="function">AStarSearch</span> {
<span class="keyword">private</span>:
    <span class="keyword">const</span> std::vector&lt;std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; directions = {
        {0, 1}, {1, 0}, {0, -1}, {-1, 0}, {1, 1}, {1, -1}, {-1, 1}, {-1, -1}
    };
    <span class="keyword">int</span> rows, cols;
    std::vector&lt;std::vector&lt;<span class="keyword">int</span>&gt;&gt; grid;

<span class="keyword">public</span>:
    AStarSearch(<span class="keyword">const</span> std::vector&lt;std::vector&lt;<span class="keyword">int</span>&gt;&gt;& _grid) 
        : grid(_grid), rows(_grid.size()), cols(_grid[0].size()) {}
    
    <span class="keyword">double</span> <span class="function">heuristic</span>(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2) {
        <span class="comment">// Euclidean distance heuristic</span>
        <span class="keyword">return</span> std::sqrt(std::pow(x2 - x1, 2) + std::pow(y2 - y1, 2));
    }
    
    <span class="keyword">bool</span> <span class="function">isValid</span>(<span class="keyword">int</span> x, <span class="keyword">int</span> y) {
        <span class="keyword">return</span> x >= 0 && x < rows && y >= 0 && y < cols && grid[x][y] == 0;
    }
    
    std::vector&lt;std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; <span class="function">findPath</span>(
            <span class="keyword">int</span> startX, <span class="keyword">int</span> startY, <span class="keyword">int</span> goalX, <span class="keyword">int</span> goalY) {
        
        <span class="comment">// Priority queue ordered by f value (lowest first)</span>
        <span class="keyword">auto</span> compare = [](<span class="keyword">const</span> Node& a, <span class="keyword">const</span> Node& b) {
            <span class="keyword">return</span> a.f > b.f;  <span class="comment">// Min-heap based on f value</span>
        };
        std::priority_queue&lt;Node, std::vector&lt;Node&gt;, decltype(compare)&gt; openList(compare);
        
        <span class="comment">// Track nodes in open and closed lists</span>
        std::unordered_map&lt;<span class="keyword">int</span>, std::unordered_map&lt;<span class="keyword">int</span>, Node&gt;&gt; nodeMap;
        std::vector&lt;std::vector&lt;<span class="keyword">bool</span>&gt;&gt; closedList(rows, std::vector&lt;<span class="keyword">bool</span>&gt;(cols, <span class="keyword">false</span>));
        
        <span class="comment">// Initialize start node</span>
        Node startNode(startX, startY);
        startNode.g = 0;
        startNode.h = heuristic(startX, startY, goalX, goalY);
        startNode.f = startNode.g + startNode.h;
        
        openList.push(startNode);
        nodeMap[startX][startY] = startNode;
        
        <span class="keyword">while</span> (!openList.empty()) {
            <span class="comment">// Get node with lowest f value</span>
            Node current = openList.top();
            openList.pop();
            
            <span class="keyword">int</span> x = current.x;
            <span class="keyword">int</span> y = current.y;
            
            <span class="comment">// Skip if already processed</span>
            <span class="keyword">if</span> (closedList[x][y]) <span class="keyword">continue</span>;
            
            <span class="comment">// Mark as processed</span>
            closedList[x][y] = <span class="keyword">true</span>;
            
            <span class="comment">// Check if reached goal</span>
            <span class="keyword">if</span> (x == goalX && y == goalY) {
                <span class="keyword">return</span> reconstructPath(nodeMap, goalX, goalY);
            }
            
            <span class="comment">// Check all possible directions</span>
            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>& dir : directions) {
                <span class="keyword">int</span> newX = x + dir.first;
                <span class="keyword">int</span> newY = y + dir.second;
                
                <span class="comment">// Skip invalid or closed cells</span>
                <span class="keyword">if</span> (!isValid(newX, newY) || closedList[newX][newY]) {
                    <span class="keyword">continue</span>;
                }
                
                <span class="comment">// Calculate new g value (cost to reach this neighbor)</span>
                <span class="keyword">double</span> moveCost = (dir.first != 0 && dir.second != 0) ? 1.414 : 1.0;
                <span class="keyword">double</span> tentativeG = current.g + moveCost;
                
                <span class="comment">// Check if this path is better or if node is new</span>
                <span class="keyword">if</span> (nodeMap[newX].find(newY) == nodeMap[newX].end() || 
                    tentativeG < nodeMap[newX][newY].g) {
                    
                    <span class="comment">// Create or update neighbor node</span>
                    Node neighbor(newX, newY);
                    neighbor.g = tentativeG;
                    neighbor.h = heuristic(newX, newY, goalX, goalY);
                    neighbor.f = neighbor.g + neighbor.h;
                    neighbor.parent = {x, y};
                    
                    nodeMap[newX][newY] = neighbor;
                    openList.push(neighbor);
                }
            }
        }
        
        <span class="comment">// No path found</span>
        <span class="keyword">return</span> {};
    }
    
    std::vector&lt;std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; <span class="function">reconstructPath</span>(
            <span class="keyword">const</span> std::unordered_map&lt;<span class="keyword">int</span>, std::unordered_map&lt;<span class="keyword">int</span>, Node&gt;&gt;& nodeMap,
            <span class="keyword">int</span> goalX, <span class="keyword">int</span> goalY) {
        
        std::vector&lt;std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; path;
        <span class="keyword">int</span> x = goalX, y = goalY;
        
        <span class="keyword">while</span> (x != -1 && y != -1) {
            path.push_back({x, y});
            <span class="keyword">const</span> <span class="keyword">auto</span>& parent = nodeMap.at(x).at(y).parent;
            x = parent.first;
            y = parent.second;
        }
        
        std::reverse(path.begin(), path.end());
        <span class="keyword">return</span> path;
    }
};</code></pre>
            </div>
          </div>

          <div class="amazon-applications">
            <h3>Applications in Amazon's Ecosystem</h3>

            <div class="application-card">
              <h4>
                <i class="fas fa-shipping-fast"></i> Last-Mile Delivery
                Optimization
              </h4>
              <p>
                Amazon uses informed search to optimize delivery routes for its
                massive logistics network:
              </p>
              <ul>
                <li>
                  <strong>A* Application:</strong> Computing optimal delivery
                  routes considering distance, traffic patterns, and delivery
                  time windows
                </li>
                <li>
                  <strong>Custom Heuristics:</strong> Incorporating historical
                  delivery data, traffic predictions, and driver performance
                </li>
                <li>
                  Reduces average delivery time by 17% while optimizing for fuel
                  consumption and driver workload
                </li>
              </ul>
            </div>

            <div class="application-card">
              <h4><i class="fas fa-robot"></i> Amazon Robotics Navigation</h4>
              <p>
                Fulfillment center robots use informed search algorithms to
                navigate efficiently:
              </p>
              <ul>
                <li>
                  <strong>Multi-Agent A*:</strong> Coordinating hundreds of
                  robots simultaneously without collisions
                </li>
                <li>
                  <strong>Dynamic Replanning:</strong> Adjusting paths in
                  real-time when obstacles appear or priorities change
                </li>
                <li>
                  Enables the movement of over 300 million products per day with
                  99.99% accuracy
                </li>
              </ul>
            </div>

            <div class="application-card">
              <h4>
                <i class="fas fa-search-dollar"></i> Inventory Placement
                Strategy
              </h4>
              <p>
                Informed search algorithms determine optimal inventory
                placement:
              </p>
              <ul>
                <li>
                  <strong>Iterative-Deepening A*:</strong> Finding optimal
                  placement considering storage constraints, demand forecasting,
                  and shipping costs
                </li>
                <li>
                  <strong>Domain-Specific Heuristics:</strong> Factoring in
                  seasonality, product dimensions, and regional demand patterns
                </li>
                <li>
                  Reduces average shipping distance by 24% and cuts fulfillment
                  costs by up to 12%
                </li>
              </ul>
            </div>

            <div class="application-card">
              <h4>
                <i class="fas fa-broadcast-tower"></i> AWS Network Routing
              </h4>
              <p>
                Amazon Web Services leverages informed search for cloud
                infrastructure:
              </p>
              <ul>
                <li>
                  <strong>Weighted A* Variants:</strong> Optimizing data routing
                  across the global AWS network
                </li>
                <li>
                  <strong>Dynamic Heuristics:</strong> Adapting to current
                  network conditions, congestion, and service priorities
                </li>
                <li>
                  Maintains 99.999% availability while optimizing for both
                  latency and bandwidth utilization
                </li>
              </ul>
            </div>

            <div class="relationship-diagram">
              <h4>A* Search Visualization</h4>
              <div class="diagram-container">
                <img
                  src="http://buildnewgames.com/assets/article//astar/Dijkstra_Animation.gif"
                  alt="A* Search Visualization"
                  style="max-width: 100%; height: auto"
                />
              </div>
            </div>

            <div class="efficiency-metrics">
              <h4>Performance Impact at Amazon</h4>
              <div class="metrics-grid">
                <div class="metric-card">
                  <h5>Time Efficiency</h5>
                  <div class="metric-value">91%</div>
                  <p class="metric-description">
                    Fewer nodes explored vs. uninformed search
                  </p>
                </div>
                <div class="metric-card">
                  <h5>Route Optimization</h5>
                  <div class="metric-value">-22%</div>
                  <p class="metric-description">
                    Reduction in delivery distance using A*
                  </p>
                </div>
                <div class="metric-card">
                  <h5>Cost Savings</h5>
                  <div class="metric-value">$287M</div>
                  <p class="metric-description">
                    Annual logistics savings from optimized routing
                  </p>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section> -->

    <!---------------------- Case Study 3 A* Algorithm -----------------------------  -->

    <!---------------------- Case Study 4: Heuristics and Dynamic Weights ----------------------------- -->
    <!-- 
    <section class="algorithm-case-study">
      <div class="container">
        <div class="case-study-header">
          <p class="case-study-subtitle">Algorithm Analysis</p>
          <h2 class="case-study-title">Heuristics and Dynamic Weights</h2>
          <p class="case-study-intro">
            Exploring how intelligent heuristic design and dynamic weight
            adjustment drive Amazon's decision-making systems across logistics,
            pricing, recommendations, and inventory management.
          </p>
        </div>

        <div class="algorithm-grid">
          <div class="algorithm-explanation">
            <h3>The Art and Science of Heuristic Functions</h3>
            <p>
              Heuristics are intelligent shortcuts that estimate the distance to
              a solution without having to calculate the exact path. They
              transform blind searches into guided journeys, dramatically
              improving efficiency for complex problems where optimal solutions
              would be computationally prohibitive.
            </p>
            <p>
              At Amazon, heuristics enable real-time decision-making across
              massive datasets and complex networks, turning what would be
              intractable computational problems into manageable approximations.
            </p>

            <div class="heuristic-types">
              <h4>Key Heuristic Properties</h4>
              <div class="property-grid">
                <div class="property-card">
                  <h5>Admissibility</h5>
                  <p>
                    Never overestimates the true cost to the goal, ensuring
                    optimal solutions when used with algorithms like A*
                  </p>
                </div>
                <div class="property-card">
                  <h5>Consistency</h5>
                  <p>
                    Satisfies the triangle inequality, ensuring that estimates
                    decrease as we get closer to the goal
                  </p>
                </div>
                <div class="property-card">
                  <h5>Informedness</h5>
                  <p>
                    More accurate estimates lead to faster convergence,
                    balancing computation cost against solution quality
                  </p>
                </div>
              </div>
            </div>

            <div class="algorithm-steps">
              <h4>Dynamic Weight Calculation Process:</h4>
              <ol>
                <li>
                  Start with a base heuristic function (h(n)) that estimates
                  distance to goal
                </li>
                <li>
                  Apply a weight multiplier (w) to create weighted function
                  (f(n) = g(n) + w cdot h(n))
                </li>
                <li>
                  Dynamically adjust weight (w) based on:
                  <ul>
                    <li>
                      Time constraints (reduce weight as time pressure
                      increases)
                    </li>
                    <li>
                      Solution quality requirements (increase weight for higher
                      accuracy)
                    </li>
                    <li>
                      Problem-specific characteristics (traffic patterns,
                      inventory levels, etc.)
                    </li>
                    <li>Available computational resources</li>
                  </ul>
                </li>
                <li>
                  Implement learning mechanisms to fine-tune weights based on
                  historical performance
                </li>
                <li>Periodically re-evaluate weights as conditions change</li>
              </ol>
            </div>

            <div class="code-snippet">
              <pre><code><span class="comment">// C++ implementation of dynamically weighted heuristic search</span>
<span class="keyword">#include</span> <span class="string">&lt;iostream&gt;</span>
<span class="keyword">#include</span> <span class="string">&lt;vector&gt;</span>
<span class="keyword">#include</span> <span class="string">&lt;queue&gt;</span>
<span class="keyword">#include</span> <span class="string">&lt;unordered_map&gt;</span>
<span class="keyword">#include</span> <span class="string">&lt;chrono&gt;</span>
<span class="keyword">#include</span> <span class="string">&lt;algorithm&gt;</span>

<span class="keyword">class</span> <span class="function">DynamicWeightedSearch</span> {
<span class="keyword">private</span>:
    <span class="comment">// Context data for weight adjustment</span>
    <span class="keyword">struct</span> SearchContext {
        <span class="keyword">double</span> baseWeight = 1.0;
        <span class="keyword">double</span> timeConstraint;     <span class="comment">// max allowed search time</span>
        <span class="keyword">double</span> qualityThreshold;   <span class="comment">// required solution quality</span>
        <span class="keyword">double</span> trafficFactor;      <span class="comment">// current traffic conditions</span>
        <span class="keyword">int</span> expandedNodes = 0;     <span class="comment">// nodes expanded so far</span>
        std::chrono::time_point&lt;std::chrono::steady_clock&gt; startTime;
    };

    SearchContext context;

<span class="keyword">public</span>:
    DynamicWeightedSearch(<span class="keyword">double</span> timeConstraint, <span class="keyword">double</span> qualityThreshold,
                           <span class="keyword">double</span> trafficFactor) {
        context.timeConstraint = timeConstraint;
        context.qualityThreshold = qualityThreshold;
        context.trafficFactor = trafficFactor;
        context.startTime = std::chrono::steady_clock::now();
    }
    
    <span class="comment">// Base distance heuristic (e.g., Euclidean distance)</span>
    <span class="keyword">double</span> <span class="function">baseHeuristic</span>(<span class="keyword">const</span> std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;& current, 
                          <span class="keyword">const</span> std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;& goal) {
        <span class="keyword">return</span> std::sqrt(std::pow(goal.first - current.first, 2) + 
                       std::pow(goal.second - current.second, 2));
    }
    
    <span class="comment">// Dynamic traffic-aware heuristic</span>
    <span class="keyword">double</span> <span class="function">trafficAwareHeuristic</span>(<span class="keyword">const</span> std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;& current,
                                <span class="keyword">const</span> std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;& goal,
                                <span class="keyword">const</span> std::vector&lt;std::vector&lt;<span class="keyword">double</span>&gt;&gt;& trafficGrid) {
        <span class="keyword">double</span> distance = baseHeuristic(current, goal);
        <span class="keyword">double</span> trafficMultiplier = 1.0 + trafficGrid[current.first][current.second];
        <span class="keyword">return</span> distance * trafficMultiplier;
    }
    
    <span class="comment">// Calculate dynamic weight based on search context</span>
    <span class="keyword">double</span> <span class="function">calculateDynamicWeight</span>() {
        <span class="keyword">double</span> weight = context.baseWeight;
        
        <span class="comment">// Time pressure adjustment</span>
        <span class="keyword">auto</span> elapsed = std::chrono::steady_clock::now() - context.startTime;
        <span class="keyword">double</span> elapsedSeconds = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(elapsed).count() / 1000.0;
        <span class="keyword">double</span> timeRatio = elapsedSeconds / context.timeConstraint;
        
        <span class="comment">// As time pressure increases, increase weight to favor faster solutions</span>
        <span class="keyword">if</span> (timeRatio > 0.7) {
            weight *= (1.0 + timeRatio);  <span class="comment">// Weight increases as time runs out</span>
        }
        
        <span class="comment">// Traffic condition adjustment</span>
        <span class="keyword">if</span> (context.trafficFactor > 1.5) {
            weight *= 0.8;  <span class="comment">// More careful planning in heavy traffic</span>
        }
        
        <span class="comment">// Solution quality adjustment</span>
        <span class="keyword">if</span> (context.qualityThreshold > 0.9) {
            weight *= 0.7;  <span class="comment">// Higher quality requirement, lower weight</span>
        }
        
        <span class="comment">// Expanded nodes adjustment - if search is taking too long</span>
        <span class="keyword">if</span> (context.expandedNodes > 10000) {
            weight *= 1.5;  <span class="comment">// Speed up search if too many nodes expanded</span>
        }
        
        <span class="keyword">return</span> std::max(0.5, std::min(weight, 3.0));  <span class="comment">// Clamp between 0.5 and 3.0</span>
    }
    
    <span class="comment">// A* search with dynamic weights</span>
    <span class="keyword">bool</span> <span class="function">findPath</span>(<span class="keyword">const</span> std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;& start,
                    <span class="keyword">const</span> std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;& goal,
                    <span class="keyword">const</span> std::vector&lt;std::vector&lt;<span class="keyword">int</span>&gt;&gt;& grid,
                    <span class="keyword">const</span> std::vector&lt;std::vector&lt;<span class="keyword">double</span>&gt;&gt;& trafficGrid,
                    std::vector&lt;std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;& path) {
        
        <span class="comment">// A* search implementation with periodic weight recalculation</span>
        <span class="comment">// For every N nodes expanded, recalculate the weight</span>
        <span class="keyword">const</span> <span class="keyword">int</span> WEIGHT_UPDATE_FREQUENCY = 100;
        
        <span class="comment">// Main search loop here...
        // Pseudocode:
        // - Initialize open/closed lists
        // - While open list not empty:
        //   - Get node with lowest f = g + w*h
        //   - If node is goal, reconstruct and return path
        //   - For each neighbor:
        //     - Calculate new g score
        //     - If better path found:
        //       - Update g, h, f values
        //       - Update parent pointer
        //       - Add to open list
        //   - Every WEIGHT_UPDATE_FREQUENCY nodes:
        //     - Recalculate weight using calculateDynamicWeight()
        //     - Update f values in open list</span>
        
        <span class="comment">// Sample weight update code during search:</span>
        context.expandedNodes++;
        <span class="keyword">if</span> (context.expandedNodes % WEIGHT_UPDATE_FREQUENCY == 0) {
            <span class="keyword">double</span> newWeight = calculateDynamicWeight();
            std::cout << "Adjusted weight: " << newWeight << std::endl;
            <span class="comment">// Update weights in priority queue...</span>
        }
        
        <span class="keyword">return</span> <span class="keyword">true</span>;  <span class="comment">// Return success/failure</span>
    }
};</code></pre>
            </div>
          </div>

          <div class="amazon-applications">
            <h3>Applications in Amazon's Ecosystem</h3>

            <div class="application-card">
              <h4>
                <i class="fas fa-route"></i> Dynamic Delivery Route Optimization
              </h4>
              <p>
                Amazon's delivery network uses adaptive heuristics to balance
                multiple competing factors:
              </p>
              <ul>
                <li>
                  <strong>Time-Dependent Weights:</strong> Adjust route
                  priorities based on time-of-day traffic patterns and promised
                  delivery windows
                </li>
                <li>
                  <strong>Weather-Adjusted Heuristics:</strong> Automatically
                  increase travel time estimates in poor weather conditions
                  using dynamic weighting
                </li>
                <li>
                  <strong>Custom Constraint Handling:</strong> Package priority,
                  vehicle capacity, and driver work-hour limitations factor into
                  weight calculations
                </li>
                <li>
                  <strong>Results:</strong> 22% improvement in on-time delivery
                  rate with 17% reduction in total driven miles
                </li>
              </ul>
            </div>

            <div class="application-card">
              <h4><i class="fas fa-tags"></i> Dynamic Pricing Engine</h4>
              <p>
                Amazon's pricing algorithms use sophisticated heuristics to
                optimize margins while remaining competitive:
              </p>
              <ul>
                <li>
                  <strong>Competitive Position Heuristic:</strong> Estimates the
                  optimal price point considering competitive offerings and
                  customer price sensitivity
                </li>
                <li>
                  <strong>Inventory-Aware Weighting:</strong> Dynamically
                  adjusts price elasticity based on stock levels and
                  replenishment timelines
                </li>
                <li>
                  <strong>Temporal Pattern Recognition:</strong> Identifies
                  buying patterns to adjust weights for seasonal demands and
                  flash sale opportunities
                </li>
                <li>
                  <strong>Results:</strong> 15% higher conversion rate with 7%
                  increase in overall margin through intelligent pricing
                </li>
              </ul>
            </div>

            <div class="application-card">
              <h4><i class="fas fa-warehouse"></i> Smart Warehouse Slotting</h4>
              <p>
                Amazon optimizes warehouse storage through adaptive heuristic
                approach:
              </p>
              <ul>
                <li>
                  <strong>Co-purchase Affinity Heuristic:</strong> Items
                  frequently purchased together receive lower distance estimates
                  to optimize picking efficiency
                </li>
                <li>
                  <strong>Velocity-Based Weighting:</strong> Fast-moving
                  products receive higher weights in placement algorithms to
                  minimize travel distance
                </li>
                <li>
                  <strong>Seasonal Adjustment Factors:</strong> Dynamic weights
                  shift based on approaching holidays or promotional events
                </li>
                <li>
                  <strong>Results:</strong> 31% reduction in average picking
                  time and 24% increase in warehouse throughput capacity
                </li>
              </ul>
            </div>

            <div class="application-card">
              <h4><i class="fas fa-laptop"></i> AWS Resource Allocation</h4>
              <p>
                Amazon Web Services employs dynamic weighted heuristics for
                efficient cloud infrastructure:
              </p>
              <ul>
                <li>
                  <strong>Predictive Load Heuristics:</strong> Anticipate
                  computational demand to pre-allocate resources before they're
                  needed
                </li>
                <li>
                  <strong>Multi-objective Weighting:</strong> Balance
                  performance, cost, reliability, and energy consumption through
                  dynamic weight adjustment
                </li>
                <li>
                  <strong>Latency-Sensitive Calculation:</strong> Adjust weights
                  based on geographical proximity and network conditions
                </li>
                <li>
                  <strong>Results:</strong> 99.999% service uptime with 28%
                  lower resource costs compared to static allocation methods
                </li>
              </ul>
            </div>

            <div class="visual-insight">
              <h4>Heuristic Weight Adaptation in Action</h4>
              <div class="chart-container">
                <img
                  src="https://i.imgur.com/NYPfmLK.png"
                  alt="Dynamic Weight Adjustment"
                  style="max-width: 100%; height: auto"
                />
              </div>
              <p class="chart-caption">
                Dynamic weight adjustment process showing how Amazon's routing
                algorithms adapt weight factors based on time pressure, traffic
                conditions, and solution quality requirements
              </p>
            </div>

            <div class="efficiency-metrics">
              <h4>Performance Benefits of Advanced Heuristics</h4>
              <div class="metrics-grid">
                <div class="metric-card">
                  <h5>Computational Savings</h5>
                  <div class="metric-value">94%</div>
                  <p class="metric-description">
                    Reduction in nodes explored vs. traditional search methods
                  </p>
                </div>
                <div class="metric-card">
                  <h5>Response Time</h5>
                  <div class="metric-value">42ms</div>
                  <p class="metric-description">
                    Average decision time across millions of routing problems
                  </p>
                </div>
                <div class="metric-card">
                  <h5>Solution Quality</h5>
                  <div class="metric-value">97.2%</div>
                  <p class="metric-description">
                    Average optimality compared to exhaustive search
                  </p>
                </div>
              </div>
            </div>

            <br />
            <br />
            <div class="key-insights">
              <h3>Key Insights on Heuristics and Dynamic Weights</h3>
              <ul>
                <li>
                  Carefully designed heuristics enable Amazon to solve complex
                  optimization problems in milliseconds that would otherwise
                  take hours
                </li>
                <li>
                  Dynamic weight adjustment allows algorithms to adapt to
                  changing conditions and constraints in real-time
                </li>
                <li>
                  The balance between solution quality and computation speed can
                  be precisely controlled through intelligent weight tuning
                </li>
                <li>
                  Heuristics with domain-specific knowledge dramatically
                  outperform generic approaches across Amazon's diverse business
                  areas
                </li>
              </ul>
            </div>

            <div class="feature-box">
              <h4>Advanced Heuristic Techniques in Amazon's Systems</h4>
              <div class="feature-grid" style="color: black">
                <div class="feature-item">
                  <i class="fas fa-brain"></i>
                  <h5>Machine Learning Heuristics</h5>
                  <p>
                    Learned from historical delivery data to improve initial
                    estimates and adapt to changing conditions
                  </p>
                </div>
                <div class="feature-item">
                  <i class="fas fa-project-diagram"></i>
                  <h5>Multi-level Heuristics</h5>
                  <p>
                    Combining coarse and fine-grained estimates for hierarchical
                    problem-solving across global networks
                  </p>
                </div>
                <div class="feature-item">
                  <i class="fas fa-balance-scale"></i>
                  <h5>Pattern Database Heuristics</h5>
                  <p>
                    Precomputed lookup tables for common subproblems in routing
                    and warehouse operations
                  </p>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

    </section> -->

    <!---------------------- Case Study 4: Heuristics and Dynamic Weights ----------------------------- -->

    <!-- Shortest Path ALgorithm -->

    <!---------------------- Case Study: Shortest Path Algorithms ----------------------------- -->

    <section class="algorithm-case-study">
      <div class="container">
        <div class="case-study-header">
          <p class="case-study-subtitle">Algorithm Analysis</p>
          <h2 class="case-study-title">
            1. Computation of Shortest Path in Maps and Warehouses
          </h2>
          <p class="case-study-intro">
            Exploring how Dijkstra's algorithm, Bellman-Ford, and other shortest
            path algorithms form the backbone of Amazon's global logistics
            network, enabling efficient delivery routing, warehouse navigation,
            and optimizing the entire supply chain.
          </p>
        </div>

        <div class="algorithm-grid">
          <div class="algorithm-explanation">
            <h3>Understanding Shortest Path Algorithms</h3>
            <p>
              Shortest path algorithms solve the fundamental problem of finding
              the most efficient path between two points in a weighted graph.
              Amazon leverages these algorithms extensively to optimize its vast
              logistics and delivery operations, saving millions in operational
              costs.
            </p>

            <div class="algorithm-comparison">
              <div class="algorithm-card">
                <h4>Dijkstra's Algorithm</h4>
                <p>
                  Dijkstra's algorithm finds the shortest path from a source
                  node to all other nodes in a graph with non-negative edge
                  weights, making it ideal for road networks and delivery
                  planning.
                </p>
                <ul>
                  <li>
                    Time complexity: O(V²) or O(E + V log V) with priority queue
                  </li>
                  <li>Does not work with negative edge weights</li>
                  <li>Widely used for road navigation systems</li>
                  <li>
                    Greedy approach that always chooses the next closest vertex
                  </li>
                </ul>
              </div>

              <div class="algorithm-card">
                <h4>Bellman-Ford Algorithm</h4>
                <p>
                  Bellman-Ford handles graphs with negative edge weights and
                  detects negative cycles, making it suitable for more complex
                  routing problems with varying constraints.
                </p>
                <ul>
                  <li>Time complexity: O(VE) - slower than Dijkstra's</li>
                  <li>Can handle negative edge weights</li>
                  <li>Detects negative cycles in the graph</li>
                  <li>Useful when costs may dynamically decrease</li>
                </ul>
              </div>
            </div>

            <div class="algorithm-steps">
              <h4>Key Steps of Dijkstra's Algorithm:</h4>
              <ol>
                <li>
                  Initialize distances: set source to 0, all others to infinity
                </li>
                <li>
                  Create a priority queue and add all vertices with their
                  distances
                </li>
                <li>
                  While the priority queue is not empty:
                  <ul>
                    <li>
                      Extract the vertex with minimum distance (let's call it u)
                    </li>
                    <li>
                      For each adjacent vertex v of u:
                      <ul>
                        <li>
                          Calculate distance = distance[u] + weight of edge (u,
                          v)
                        </li>
                        <li>
                          If this distance is less than the current distance[v],
                          update distance[v]
                        </li>
                      </ul>
                    </li>
                  </ul>
                </li>
                <li>
                  Return the array of shortest distances from source to all
                  vertices
                </li>
              </ol>
            </div>

            <div class="code-snippet">
              <pre><code><span class="comment">// C++ implementation of Dijkstra's algorithm</span>
<span class="keyword">#include</span> <span class="string">&lt;iostream&gt;</span>
<span class="keyword">#include</span> <span class="string">&lt;vector&gt;</span>
<span class="keyword">#include</span> <span class="string">&lt;queue&gt;</span>
<span class="keyword">#include</span> <span class="string">&lt;limits&gt;</span>

<span class="keyword">class</span> <span class="function">ShortestPath</span> {
<span class="keyword">private</span>:
    <span class="keyword">int</span> vertices;
    std::vector&lt;std::vector&lt;std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; adjacencyList;

<span class="keyword">public</span>:
    ShortestPath(<span class="keyword">int</span> v) {
        vertices = v;
        adjacencyList.resize(v);
    }

    <span class="keyword">void</span> <span class="function">addEdge</span>(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> weight) {
        adjacencyList[u].push_back({v, weight});
        adjacencyList[v].push_back({u, weight}); <span class="comment">// For undirected graph</span>
    }

    std::vector&lt;<span class="keyword">int</span>&gt; <span class="function">dijkstra</span>(<span class="keyword">int</span> source) {
        <span class="comment">// Min-heap priority queue to extract vertex with minimum distance</span>
        std::priority_queue&lt;std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, 
                         std::vector&lt;std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;, 
                         std::greater&lt;std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; pq;
        
        <span class="comment">// Vector to store distances from source to all vertices</span>
        std::vector&lt;<span class="keyword">int</span>&gt; distance(vertices, std::numeric_limits&lt;<span class="keyword">int</span>&gt;::max());
        
        <span class="comment">// Distance from source to itself is 0</span>
        distance[source] = 0;
        pq.push({0, source});
        
        <span class="keyword">while</span> (!pq.empty()) {
            <span class="keyword">int</span> dist = pq.top().first;
            <span class="keyword">int</span> u = pq.top().second;
            pq.pop();
            
            <span class="comment">// Skip if we've already found a better path</span>
            <span class="keyword">if</span> (dist > distance[u]) <span class="keyword">continue</span>;
            
            <span class="comment">// Examine all neighbors of current vertex</span>
            <span class="keyword">for</span> (<span class="keyword">auto</span> edge : adjacencyList[u]) {
                <span class="keyword">int</span> v = edge.first;
                <span class="keyword">int</span> weight = edge.second;
                
                <span class="comment">// If we found a shorter path to v through u</span>
                <span class="keyword">if</span> (distance[u] + weight < distance[v]) {
                    distance[v] = distance[u] + weight;
                    pq.push({distance[v], v});
                }
            }
        }
        
        <span class="keyword">return</span> distance;
    }
    
    <span class="comment">// Bellman-Ford algorithm implementation</span>
    std::pair&lt;std::vector&lt;<span class="keyword">int</span>&gt;, <span class="keyword">bool</span>&gt; <span class="function">bellmanFord</span>(<span class="keyword">int</span> source) {
        std::vector&lt;<span class="keyword">int</span>&gt; distance(vertices, std::numeric_limits&lt;<span class="keyword">int</span>&gt;::max());
        distance[source] = 0;
        
        <span class="comment">// Relax all edges V-1 times</span>
        <span class="keyword">for</span> (<span class="keyword">int</span> i = 0; i < vertices - 1; i++) {
            <span class="keyword">for</span> (<span class="keyword">int</span> u = 0; u < vertices; u++) {
                <span class="keyword">for</span> (<span class="keyword">auto</span> edge : adjacencyList[u]) {
                    <span class="keyword">int</span> v = edge.first;
                    <span class="keyword">int</span> weight = edge.second;
                    <span class="keyword">if</span> (distance[u] != std::numeric_limits&lt;<span class="keyword">int</span>&gt;::max() && 
                        distance[u] + weight < distance[v]) {
                        distance[v] = distance[u] + weight;
                    }
                }
            }
        }
        
        <span class="comment">// Check for negative weight cycles</span>
        <span class="keyword">bool</span> hasNegativeCycle = <span class="keyword">false</span>;
        <span class="keyword">for</span> (<span class="keyword">int</span> u = 0; u < vertices; u++) {
            <span class="keyword">for</span> (<span class="keyword">auto</span> edge : adjacencyList[u]) {
                <span class="keyword">int</span> v = edge.first;
                <span class="keyword">int</span> weight = edge.second;
                <span class="keyword">if</span> (distance[u] != std::numeric_limits&lt;<span class="keyword">int</span>&gt;::max() && 
                    distance[u] + weight < distance[v]) {
                    hasNegativeCycle = <span class="keyword">true</span>;
                    <span class="keyword">break</span>;
                }
            }
        }
        
        <span class="keyword">return</span> {distance, hasNegativeCycle};
    }
};</code></pre>
            </div>
          </div>

          <div class="amazon-applications">
            <h3>Applications in Amazon's Ecosystem</h3>

            <div class="application-card">
              <h4>
                <i class="fas fa-truck"></i> Last-Mile Delivery Optimization
              </h4>
              <p>
                Amazon uses sophisticated shortest path algorithms to optimize
                delivery routes for its fleet of vehicles:
              </p>
              <ul>
                <li>
                  <strong>Dynamic Routing:</strong> Real-time route
                  recalculation based on traffic conditions, weather, and
                  delivery priorities
                </li>
                <li>
                  <strong>Multi-Stop Optimization:</strong> Using advanced
                  variants of shortest path algorithms to optimize routes with
                  dozens of delivery stops
                </li>
                <li>
                  <strong>Time-Window Constraints:</strong> Incorporating
                  delivery time windows and driver schedules into the path
                  computation
                </li>
                <li>
                  Enables Amazon to deliver over 10 billion packages annually
                  with industry-leading efficiency
                </li>
              </ul>
            </div>

            <div class="application-card">
              <h4>
                <i class="fas fa-warehouse"></i> Fulfillment Center Navigation
              </h4>
              <p>
                Inside Amazon's massive fulfillment centers, shortest path
                algorithms guide both human pickers and robots:
              </p>
              <ul>
                <li>
                  <strong>Robotic Path Planning:</strong> Amazon's fleet of over
                  350,000 mobile drive units navigate warehouse floors using
                  modified Dijkstra's algorithm
                </li>
                <li>
                  <strong>Multi-Agent Coordination:</strong> Preventing path
                  conflicts among thousands of robots operating simultaneously
                </li>
                <li>
                  <strong>Dynamic Obstacle Avoidance:</strong> Real-time path
                  adjustment when obstructions are detected
                </li>
                <li>
                  Increases picking efficiency by 2-3x compared to traditional
                  warehouse operations
                </li>
              </ul>
            </div>

            <div class="application-card">
              <h4>
                <i class="fas fa-map-marked-alt"></i> Supply Chain Network
                Design
              </h4>
              <p>
                Amazon uses shortest path algorithms at the macro level to
                optimize its entire distribution network:
              </p>
              <ul>
                <li>
                  <strong>Facility Location Optimization:</strong> Determining
                  optimal placement of new fulfillment centers using network
                  distance calculations
                </li>
                <li>
                  <strong>Cross-Docking Strategy:</strong> Optimizing the flow
                  of goods between fulfillment centers to minimize shipping
                  distance and time
                </li>
                <li>
                  <strong>Regional Inventory Placement:</strong> Strategic
                  product placement based on shortest path to customer
                  population centers
                </li>
                <li>
                  Enables Amazon to maintain 1-2 day delivery to over 72% of the
                  US population
                </li>
              </ul>
            </div>

            <div class="relationship-diagram">
              <h4>Amazon's Shortest Path Applications</h4>
              <div class="diagram-container">
                <img
                  src="https://i.imgur.com/Gbjp2rD.png"
                  alt="Shortest Path Applications in Amazon"
                  style="max-width: 100%; height: auto"
                />
              </div>
            </div>

            <div class="efficiency-metrics">
              <h4>Business Impact at Amazon</h4>
              <div class="metrics-grid">
                <div class="metric-card">
                  <h5>Delivery Efficiency</h5>
                  <div class="metric-value">+24%</div>
                  <p class="metric-description">
                    Increase in packages delivered per driver-hour
                  </p>
                </div>
                <div class="metric-card">
                  <h5>Fuel Savings</h5>
                  <div class="metric-value">$89M</div>
                  <p class="metric-description">
                    Annual reduction in fuel costs from optimized routes
                  </p>
                </div>
                <div class="metric-card">
                  <h5>Carbon Reduction</h5>
                  <div class="metric-value">29%</div>
                  <p class="metric-description">
                    Decrease in carbon emissions per package delivered
                  </p>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!---------------------- Case Study: Shortest Path Algorithms ----------------------------- -->

    <!---------------------- Case Study: Range Query Optimization ----------------------------- -->
    <section class="algorithm-case-study">
      <div class="container">
        <div class="case-study-header">
          <p class="case-study-subtitle">Algorithm Analysis</p>
          <h2 class="case-study-title">Range Query Optimization</h2>
          <p class="case-study-intro">
            Exploring how advanced range query algorithms power Amazon's
            database systems, inventory management, pricing strategies, and
            recommendation engines, enabling efficient processing of billions of
            queries across petabytes of data.
          </p>
        </div>

        <div class="algorithm-grid">
          <div class="algorithm-explanation">
            <h3>Understanding Range Query Optimization</h3>
            <p>
              Range queries involve retrieving data within specific intervals or
              boundaries. Amazon's scale demands specialized algorithms that can
              efficiently search, filter, and analyze massive datasets without
              examining every record. These algorithms create optimized data
              structures that support logarithmic or better time complexity for
              range operations.
            </p>

            <div class="algorithm-comparison">
              <div class="algorithm-card">
                <h4>Segment Trees</h4>
                <p>
                  Segment trees provide efficient solutions for range queries
                  and updates through a hierarchical tree structure that
                  partitions the data into segments.
                </p>
                <ul>
                  <li>Time complexity: O(log n) for queries and updates</li>
                  <li>Space complexity: O(n) for storing the tree</li>
                  <li>
                    Excellent for applications requiring frequent range updates
                  </li>
                  <li>
                    Supports various aggregate operations (min, max, sum, etc.)
                  </li>
                </ul>
              </div>

              <div class="algorithm-card">
                <h4>R-Trees & Spatial Indexing</h4>
                <p>
                  R-Trees organize multi-dimensional data for efficient spatial
                  range queries, making them ideal for geographical and product
                  attribute searches.
                </p>
                <ul>
                  <li>Time complexity: O(log n) for average case queries</li>
                  <li>Optimized for multi-dimensional data</li>
                  <li>Minimizes overlap between bounding boxes</li>
                  <li>
                    Self-balancing to maintain performance with dynamic data
                  </li>
                </ul>
              </div>
            </div>

            <div class="algorithm-steps">
              <h4>Key Steps of Range Query Processing in Amazon's Systems:</h4>
              <ol>
                <li>
                  Query Analysis and Optimization:
                  <ul>
                    <li>Parse incoming range query parameters</li>
                    <li>Determine optimal index and data structure to use</li>
                    <li>
                      Estimate result cardinality to allocate appropriate
                      resources
                    </li>
                  </ul>
                </li>
                <li>
                  Index Selection and Traversal:
                  <ul>
                    <li>
                      Choose appropriate specialized index (B+ Tree, R-Tree,
                      etc.)
                    </li>
                    <li>Traverse index structure to narrow search space</li>
                    <li>
                      Prune unnecessary branches to minimize I/O operations
                    </li>
                  </ul>
                </li>
                <li>
                  Parallel Processing:
                  <ul>
                    <li>Divide large range queries into sub-ranges</li>
                    <li>
                      Process sub-ranges in parallel across multiple nodes
                    </li>
                    <li>Combine results efficiently using merge algorithms</li>
                  </ul>
                </li>
                <li>
                  Result Caching and Delivery:
                  <ul>
                    <li>Cache frequently accessed range query results</li>
                    <li>Apply compression for network-efficient delivery</li>
                    <li>Stream results for large ranges to minimize latency</li>
                  </ul>
                </li>
              </ol>
            </div>

            <div class="code-snippet">
              <pre><code><span class="comment">// C++ implementation of a Segment Tree for range sum queries</span>
<span class="keyword">#include</span> <span class="string">&lt;iostream&gt;</span>
<span class="keyword">#include</span> <span class="string">&lt;vector&gt;</span>
<span class="keyword">#include</span> <span class="string">&lt;cmath&gt;</span>

<span class="keyword">class</span> <span class="function">RangeQueryProcessor</span> {
<span class="keyword">private</span>:
    std::vector&lt;<span class="keyword">int</span>&gt; segmentTree;
    <span class="keyword">int</span> n;
    
    <span class="comment">// Build segment tree from input array</span>
    <span class="keyword">void</span> <span class="function">buildSegmentTree</span>(<span class="keyword">const</span> std::vector&lt;<span class="keyword">int</span>&gt;& arr, <span class="keyword">int</span> node, <span class="keyword">int</span> start, <span class="keyword">int</span> end) {
        <span class="keyword">if</span> (start == end) {
            <span class="comment">// Leaf node will have a single element</span>
            segmentTree[node] = arr[start];
            <span class="keyword">return</span>;
        }
        
        <span class="keyword">int</span> mid = start + (end - start) / 2;
        <span class="comment">// Recursively build left and right children</span>
        buildSegmentTree(arr, 2*node+1, start, mid);
        buildSegmentTree(arr, 2*node+2, mid+1, end);
        
        <span class="comment">// Internal node will hold the sum of both of its children</span>
        segmentTree[node] = segmentTree[2*node+1] + segmentTree[2*node+2];
    }
    
    <span class="comment">// Helper function to perform range sum query</span>
    <span class="keyword">int</span> <span class="function">rangeQuerySum</span>(<span class="keyword">int</span> node, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> left, <span class="keyword">int</span> right) {
        <span class="keyword">if</span> (left > end || right < start) {
            <span class="comment">// Range represented by a node is completely outside the queried range</span>
            <span class="keyword">return</span> 0;
        }
        
        <span class="keyword">if</span> (left <= start && right >= end) {
            <span class="comment">// Range represented by a node is completely inside the queried range</span>
            <span class="keyword">return</span> segmentTree[node];
        }
        
        <span class="comment">// Range represented by a node is partially inside and partially outside the queried range</span>
        <span class="keyword">int</span> mid = start + (end - start) / 2;
        <span class="keyword">int</span> leftSum = rangeQuerySum(2*node+1, start, mid, left, right);
        <span class="keyword">int</span> rightSum = rangeQuerySum(2*node+2, mid+1, end, left, right);
        
        <span class="keyword">return</span> leftSum + rightSum;
    }
    
    <span class="comment">// Helper function to update a value</span>
    <span class="keyword">void</span> <span class="function">updateValue</span>(<span class="keyword">int</span> node, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> idx, <span class="keyword">int</span> val) {
        <span class="keyword">if</span> (start == end) {
            <span class="comment">// Leaf node</span>
            segmentTree[node] = val;
            <span class="keyword">return</span>;
        }
        
        <span class="keyword">int</span> mid = start + (end - start) / 2;
        <span class="keyword">if</span> (idx <= mid) {
            <span class="comment">// If idx is in the left child, recurse on the left child</span>
            updateValue(2*node+1, start, mid, idx, val);
        } <span class="keyword">else</span> {
            <span class="comment">// If idx is in the right child, recurse on the right child</span>
            updateValue(2*node+2, mid+1, end, idx, val);
        }
        
        <span class="comment">// Update current node based on children</span>
        segmentTree[node] = segmentTree[2*node+1] + segmentTree[2*node+2];
    }

<span class="keyword">public</span>:
    RangeQueryProcessor(<span class="keyword">const</span> std::vector&lt;<span class="keyword">int</span>&gt;& arr) {
        n = arr.size();
        
        <span class="comment">// Height of segment tree</span>
        <span class="keyword">int</span> height = (<span class="keyword">int</span>)(ceil(log2(n)));
        
        <span class="comment">// Maximum size of segment tree</span>
        <span class="keyword">int</span> maxSize = 2 * (<span class="keyword">int</span>)pow(2, height) - 1;
        
        <span class="comment">// Allocate memory for segment tree</span>
        segmentTree.resize(maxSize, 0);
        
        <span class="comment">// Build the segment tree</span>
        buildSegmentTree(arr, 0, 0, n-1);
    }
    
    <span class="comment">// Function to get sum of range [left, right]</span>
    <span class="keyword">int</span> <span class="function">queryRange</span>(<span class="keyword">int</span> left, <span class="keyword">int</span> right) {
        <span class="keyword">if</span> (left < 0 || right >= n || left > right) {
            std::cout << "Invalid range" << std::endl;
            <span class="keyword">return</span> -1;
        }
        
        <span class="keyword">return</span> rangeQuerySum(0, 0, n-1, left, right);
    }
    
    <span class="comment">// Function to update a value at position idx</span>
    <span class="keyword">void</span> <span class="function">update</span>(<span class="keyword">int</span> idx, <span class="keyword">int</span> val) {
        <span class="keyword">if</span> (idx < 0 || idx >= n) {
            std::cout << "Invalid position" << std::endl;
            <span class="keyword">return</span>;
        }
        
        updateValue(0, 0, n-1, idx, val);
    }
    
    <span class="comment">// Simulate Amazon's parallel range query processing</span>
    <span class="keyword">int</span> <span class="function">parallelRangeQuery</span>(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> numThreads) {
        <span class="keyword">if</span> (left < 0 || right >= n || left > right) {
            <span class="keyword">return</span> -1;
        }
        
        <span class="comment">// Range size to process</span>
        <span class="keyword">int</span> rangeSize = right - left + 1;
        
        <span class="comment">// Simple case: not worth parallelizing</span>
        <span class="keyword">if</span> (rangeSize <= 1000 || numThreads <= 1) {
            <span class="keyword">return</span> rangeQuerySum(0, 0, n-1, left, right);
        }
        
        <span class="comment">// Divide range into equal subranges for parallel processing</span>
        <span class="keyword">int</span> subRangeSize = rangeSize / numThreads;
        std::vector&lt;<span class="keyword">int</span>&gt; results(numThreads, 0);
        
        <span class="comment">// In a real implementation, these would be processed in parallel</span>
        <span class="comment">// Here we simulate the parallel processing</span>
        <span class="keyword">for</span> (<span class="keyword">int</span> i = 0; i < numThreads; i++) {
            <span class="keyword">int</span> subLeft = left + i * subRangeSize;
            <span class="keyword">int</span> subRight = (i == numThreads - 1) ? right : subLeft + subRangeSize - 1;
            results[i] = rangeQuerySum(0, 0, n-1, subLeft, subRight);
        }
        
        <span class="comment">// Combine results from all threads</span>
        <span class="keyword">int</span> totalSum = 0;
        <span class="keyword">for</span> (<span class="keyword">int</span> result : results) {
            totalSum += result;
        }
        
        <span class="keyword">return</span> totalSum;
    }
};</code></pre>
            </div>
          </div>

          <div class="amazon-applications">
            <h3>Applications in Amazon's Ecosystem</h3>

            <div class="application-card">
              <h4>
                <i class="fas fa-database"></i> DynamoDB Query Optimization
              </h4>
              <p>
                Amazon's DynamoDB uses specialized range query algorithms to
                deliver consistent single-digit millisecond performance:
              </p>
              <ul>
                <li>
                  <strong>Adaptive Range Partitioning:</strong> Automatically
                  splits high-traffic key ranges to prevent hot partitions
                </li>
                <li>
                  <strong>Sparse Indexing:</strong> Optimized indexing
                  structures for efficient range scans across petabytes of data
                </li>
                <li>
                  <strong>Read-Ahead Prefetching:</strong> Intelligent
                  prediction of range scan patterns to minimize latency
                </li>
                <li>
                  Enables Amazon to handle more than 20 trillion requests per
                  month with 99.999% SLA compliance
                </li>
              </ul>
            </div>

            <div class="application-card">
              <h4><i class="fas fa-dollar-sign"></i> Dynamic Pricing Engine</h4>
              <p>
                Amazon's competitive pricing system uses range query
                optimization to analyze market positions:
              </p>
              <ul>
                <li>
                  <strong>Price Band Indexing:</strong> Multi-dimensional range
                  structures organizing products by price point, category, and
                  competitor positioning
                </li>
                <li>
                  <strong>Temporal Range Analysis:</strong> Specialized
                  algorithms for analyzing price change patterns over time
                </li>
                <li>
                  <strong>Layered Range Filters:</strong> Progressive filtering
                  across price ranges, product attributes, and market segments
                </li>
                <li>
                  Powers over 2.5 million daily price adjustments with an
                  average decision time of 12ms
                </li>
              </ul>
            </div>

            <div class="application-card">
              <h4><i class="fas fa-boxes"></i> Inventory Management System</h4>
              <p>
                Amazon's fulfillment centers leverage advanced range query
                algorithms for inventory tracking:
              </p>
              <ul>
                <li>
                  <strong>Multi-Criteria Range Search:</strong> Simultaneously
                  querying across product dimensions, weight ranges, and storage
                  constraints
                </li>
                <li>
                  <strong>Temporal Reachability:</strong> Range-based
                  forecasting of inventory depletion across time windows
                </li>
                <li>
                  <strong>Geographic Range Balancing:</strong> Optimizing
                  inventory distribution within specified geographical
                  boundaries
                </li>
                <li>
                  Maintains 99.97% inventory accuracy across billions of items
                  in over 175 fulfillment centers
                </li>
              </ul>
            </div>

            <div class="application-card">
              <h4>
                <i class="fas fa-filter"></i> Product Search and Filtering
              </h4>
              <p>
                Amazon's product search engine relies on range queries to power
                the shopping experience:
              </p>
              <ul>
                <li>
                  <strong>Faceted Range Navigation:</strong> Enabling customers
                  to filter products by price ranges, ratings, and other numeric
                  attributes
                </li>
                <li>
                  <strong>Adaptive Range Bucketing:</strong> Dynamically
                  adjusting filter ranges based on result distribution
                </li>
                <li>
                  <strong>Multi-attribute Range Intersection:</strong>
                  Efficiently processing combinations of range filters
                </li>
                <li>
                  Processes over 8 billion range-based filter operations daily
                  with sub-100ms response times
                </li>
              </ul>
            </div>

            <div class="relationship-diagram">
              <h4>Range Query Architecture at Amazon</h4>
              <div class="diagram-container">
                <img
                  src="https://i.imgur.com/XGmv3RL.png"
                  alt="Amazon Range Query Architecture"
                  style="max-width: 100%; height: auto"
                />
              </div>
            </div>

            <div class="efficiency-metrics">
              <h4>Business Impact at Amazon</h4>
              <div class="metrics-grid">
                <div class="metric-card">
                  <h5>Query Performance</h5>
                  <div class="metric-value">98.7%</div>
                  <p class="metric-description">
                    Percentage of range queries completed in under 50ms
                  </p>
                </div>
                <div class="metric-card">
                  <h5>Cost Efficiency</h5>
                  <div class="metric-value">-72%</div>
                  <p class="metric-description">
                    Reduction in compute resources compared to brute-force
                    scanning
                  </p>
                </div>
                <div class="metric-card">
                  <h5>Infrastructure Savings</h5>
                  <div class="metric-value">$347M</div>
                  <p class="metric-description">
                    Annual savings from optimized query processing
                  </p>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>
    <!---------------------- Case Study: Range Query Optimization ----------------------------- -->

    <!---------------------- Case Study: PageRank and Web Crawling ----------------------------- -->
    <section class="algorithm-case-study">
      <div class="container">
        <div class="case-study-header">
          <p class="case-study-subtitle">Algorithm Analysis</p>
          <h2 class="case-study-title">3. PageRank and Web Crawling</h2>
          <p class="case-study-intro">
            Exploring how Amazon adapts PageRank algorithms and web crawling
            technologies to power its product search engine, recommendations,
            and marketplace intelligence systems, organizing billions of
            products and customer interactions.
          </p>
        </div>

        <div class="algorithm-grid">
          <div class="algorithm-explanation">
            <h3>Understanding PageRank and Web Crawling</h3>
            <p>
              Originally developed by Google's founders, PageRank revolutionized
              search by ranking web pages based on their link structure. Amazon
              has adapted these principles to its e-commerce domain, creating
              sophisticated ranking systems that determine product visibility,
              recommendations, and marketplace dynamics.
            </p>

            <div class="algorithm-comparison">
              <div class="algorithm-card">
                <h4>PageRank Algorithm</h4>
                <p>
                  PageRank assigns importance to items in a network based on the
                  quantity and quality of connections pointing to them, using
                  recursive probability distribution.
                </p>
                <ul>
                  <li>Treats connections as "votes" with different weights</li>
                  <li>Based on random walk and Markov chain models</li>
                  <li>Iterative computation converges to stable ranking</li>
                  <li>
                    Time complexity: O(I × N) where I = iterations, N = nodes
                  </li>
                </ul>
              </div>

              <div class="algorithm-card">
                <h4>Web Crawling</h4>
                <p>
                  Crawling systematically explores and indexes information by
                  following connections between items, building a comprehensive
                  knowledge graph for searching.
                </p>
                <ul>
                  <li>Uses BFS or priority-based exploration strategies</li>
                  <li>Maintains frontier queues of items to explore</li>
                  <li>Implements politeness policies and rate limiting</li>
                  <li>Extracts structured data from unstructured sources</li>
                </ul>
              </div>
            </div>

            <div class="algorithm-steps">
              <h4>Key Steps of Amazon's Product Ranking Algorithm:</h4>
              <ol>
                <li>
                  Build a graph connecting products based on customer behavior:
                  <ul>
                    <li>
                      Co-purchase relationships ("Frequently bought together")
                    </li>
                    <li>
                      Co-view relationships ("Customers who viewed this also
                      viewed")
                    </li>
                    <li>
                      Add edges between related products with weighted
                      connections
                    </li>
                  </ul>
                </li>
                <li>Initialize all products with baseline scores (1/N)</li>
                <li>
                  For each iteration until convergence:
                  <ul>
                    <li>
                      Calculate each product's new score based on incoming
                      relationships
                    </li>
                    <li>
                      Apply damping factor to model random browsing behavior
                    </li>
                    <li>Normalize scores across the entire product catalog</li>
                  </ul>
                </li>
                <li>
                  Combine PageRank scores with other ranking signals:
                  <ul>
                    <li>Sales velocity, conversion rate, customer ratings</li>
                    <li>Relevance to search queries and user preferences</li>
                    <li>Business rules and sponsored placement factors</li>
                  </ul>
                </li>
                <li>
                  Periodically refresh rankings as new data becomes available
                </li>
              </ol>
            </div>

            <div class="code-snippet">
              <pre><code><span class="comment">// C++ implementation of Amazon-style ProductRank algorithm</span>
<span class="keyword">#include</span> <span class="string">&lt;iostream&gt;</span>
<span class="keyword">#include</span> <span class="string">&lt;vector&gt;</span>
<span class="keyword">#include</span> <span class="string">&lt;unordered_map&gt;</span>
<span class="keyword">#include</span> <span class="string">&lt;cmath&gt;</span>

<span class="keyword">class</span> <span class="function">ProductRank</span> {
<span class="keyword">private</span>:
    <span class="keyword">int</span> numProducts;
    <span class="keyword">double</span> dampingFactor;
    <span class="keyword">double</span> convergenceThreshold;
    <span class="keyword">int</span> maxIterations;
    
    <span class="comment">// Graph representation: outgoing edges from each product</span>
    std::vector&lt;std::vector&lt;std::pair&lt;<span class="keyword">int</span>, <span class="keyword">double</span>&gt;&gt;&gt; productGraph;
    
    <span class="comment">// Reverse graph for incoming connections</span>
    std::vector&lt;std::vector&lt;std::pair&lt;<span class="keyword">int</span>, <span class="keyword">double</span>&gt;&gt;&gt; reverseGraph;
    
    <span class="comment">// Additional product metadata</span>
    std::vector&lt;<span class="keyword">double</span>&gt; conversionRate;
    std::vector&lt;<span class="keyword">double</span>&gt; customerRating;
    std::vector&lt;<span class="keyword">double</span>&gt; recency;

<span class="keyword">public</span>:
    ProductRank(<span class="keyword">int</span> n, <span class="keyword">double</span> d = 0.85, <span class="keyword">double</span> thresh = 1e-8, <span class="keyword">int</span> maxIter = 100) 
        : numProducts(n), dampingFactor(d), convergenceThreshold(thresh), maxIterations(maxIter) {
        
        productGraph.resize(numProducts);
        reverseGraph.resize(numProducts);
        conversionRate.resize(numProducts, 1.0);
        customerRating.resize(numProducts, 3.0);  <span class="comment">// Default 3-star rating</span>
        recency.resize(numProducts, 1.0);
    }
    
    <span class="keyword">void</span> <span class="function">addRelationship</span>(<span class="keyword">int</span> fromProduct, <span class="keyword">int</span> toProduct, <span class="keyword">double</span> weight) {
        productGraph[fromProduct].push_back({toProduct, weight});
        reverseGraph[toProduct].push_back({fromProduct, weight});
    }
    
    <span class="keyword">void</span> <span class="function">setProductMetrics</span>(<span class="keyword">int</span> productId, <span class="keyword">double</span> conversion, 
                             <span class="keyword">double</span> rating, <span class="keyword">double</span> rec) {
        conversionRate[productId] = conversion;
        customerRating[productId] = rating;
        recency[productId] = rec;
    }
    
    std::vector&lt;<span class="keyword">double</span>&gt; <span class="function">computeProductRank</span>() {
        <span class="comment">// Initialize ranks</span>
        std::vector&lt;<span class="keyword">double</span>&gt; ranks(numProducts, 1.0 / numProducts);
        std::vector&lt;<span class="keyword">double</span>&gt; newRanks(numProducts, 0.0);
        
        <span class="keyword">double</span> diff = 1.0;
        <span class="keyword">int</span> iterations = 0;
        
        <span class="comment">// Iterative computation until convergence</span>
        <span class="keyword">while</span> (diff > convergenceThreshold && iterations < maxIterations) {
            <span class="comment">// Reset new ranks</span>
            <span class="keyword">for</span> (<span class="keyword">int</span> i = 0; i < numProducts; i++) {
                newRanks[i] = 0.0;
            }
            
            <span class="comment">// Compute contribution from each product</span>
            <span class="keyword">for</span> (<span class="keyword">int</span> i = 0; i < numProducts; i++) {
                <span class="comment">// Sum of outgoing edge weights</span>
                <span class="keyword">double</span> totalWeight = 0.0;
                <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>& edge : productGraph[i]) {
                    totalWeight += edge.second;
                }
                
                <span class="comment">// Distribute rank to connected products</span>
                <span class="keyword">if</span> (totalWeight > 0) {
                    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>& edge : productGraph[i]) {
                        <span class="keyword">int</span> toProduct = edge.first;
                        <span class="keyword">double</span> weight = edge.second;
                        newRanks[toProduct] += ranks[i] * weight / totalWeight;
                    }
                }
            }
            
            <span class="comment">// Apply damping factor</span>
            <span class="keyword">double</span> leaked = 0.0;
            <span class="keyword">for</span> (<span class="keyword">int</span> i = 0; i < numProducts; i++) {
                newRanks[i] = dampingFactor * newRanks[i];
                leaked += (1.0 - dampingFactor) / numProducts;
            }
            
            <span class="comment">// Redistribute leaked probability</span>
            <span class="keyword">for</span> (<span class="keyword">int</span> i = 0; i < numProducts; i++) {
                newRanks[i] += leaked;
            }
            
            <span class="comment">// Check for convergence</span>
            diff = 0.0;
            <span class="keyword">for</span> (<span class="keyword">int</span> i = 0; i < numProducts; i++) {
                diff += std::abs(newRanks[i] - ranks[i]);
            }
            diff /= numProducts;
            
            <span class="comment">// Update ranks</span>
            ranks.swap(newRanks);
            iterations++;
        }
        
        <span class="comment">// Combine with other ranking signals</span>
        <span class="keyword">for</span> (<span class="keyword">int</span> i = 0; i < numProducts; i++) {
            <span class="keyword">double</span> qualityScore = 0.5 * customerRating[i] / 5.0;
            <span class="keyword">double</span> performanceScore = 0.3 * conversionRate[i];
            <span class="keyword">double</span> freshnessScore = 0.2 * recency[i];
            
            <span class="comment">// Final score is a weighted combination</span>
            ranks[i] = 0.6 * ranks[i] + 0.4 * (qualityScore + performanceScore + freshnessScore);
        }
        
        <span class="keyword">return</span> ranks;
    }
    
    <span class="comment">// Simple crawler simulation for product catalog</span>
    <span class="keyword">void</span> <span class="function">crawlProductCatalog</span>(<span class="keyword">int</span> startProductId, <span class="keyword">int</span> maxProducts) {
        std::queue&lt;<span class="keyword">int</span>&gt; frontier;
        std::unordered_set&lt;<span class="keyword">int</span>&gt; visited;
        
        frontier.push(startProductId);
        visited.insert(startProductId);
        
        <span class="keyword">while</span> (!frontier.empty() && visited.size() < maxProducts) {
            <span class="keyword">int</span> currentProduct = frontier.front();
            frontier.pop();
            
            <span class="comment">// Process product (extract metadata, update index, etc.)</span>
            
            <span class="comment">// Add related products to frontier</span>
            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>& relation : productGraph[currentProduct]) {
                <span class="keyword">int</span> relatedProduct = relation.first;
                <span class="keyword">if</span> (visited.find(relatedProduct) == visited.end()) {
                    frontier.push(relatedProduct);
                    visited.insert(relatedProduct);
                }
            }
        }
    }
};</code></pre>
            </div>
          </div>

          <div class="amazon-applications">
            <h3>Applications in Amazon's Ecosystem</h3>

            <div class="application-card">
              <h4><i class="fas fa-search"></i> A9 Search Engine</h4>
              <p>
                Amazon's A9 search engine uses PageRank-inspired algorithms to
                rank products in search results:
              </p>
              <ul>
                <li>
                  <strong>Purchase-Adjusted PageRank:</strong> Products
                  frequently purchased after specific searches receive higher
                  rankings
                </li>
                <li>
                  <strong>Query Intent Recognition:</strong> The algorithm
                  identifies whether users are browsing, researching, or ready
                  to purchase
                </li>
                <li>
                  <strong>Personalized Ranking:</strong> Individual user
                  behavior creates personalized PageRank adjustments
                </li>
                <li>
                  This system processes over 5 billion search queries monthly
                  with sub-100ms response times
                </li>
              </ul>
            </div>

            <div class="application-card">
              <h4>
                <i class="fas fa-robot"></i> Competitive Intelligence Crawlers
              </h4>
              <p>
                Amazon deploys sophisticated web crawlers to monitor the
                e-commerce landscape:
              </p>
              <ul>
                <li>
                  <strong>Price Intelligence:</strong> Crawlers monitor
                  competitor pricing across millions of products
                </li>
                <li>
                  <strong>Product Catalog Expansion:</strong> Identifying new
                  products and categories in the marketplace
                </li>
                <li>
                  <strong>Dynamic Crawl Prioritization:</strong> Allocating
                  crawling resources to high-value product segments
                </li>
                <li>
                  Enables Amazon to make over 2.5 million price adjustments
                  daily based on competitive intelligence
                </li>
              </ul>
            </div>

            <div class="application-card">
              <h4><i class="fas fa-users"></i> Amazon Recommendations</h4>
              <p>
                The "Customers who bought this also bought" feature combines
                collaborative filtering with PageRank concepts:
              </p>
              <ul>
                <li>
                  <strong>Purchase Graph Analysis:</strong> Building a massive
                  graph of product relationships based on purchase patterns
                </li>
                <li>
                  <strong>Random Walk Models:</strong> Using PageRank-like
                  random walks to discover product affinity clusters
                </li>
                <li>
                  <strong>Temporal Sensitivity:</strong> Recent purchases
                  receive higher weights in the recommendation graph
                </li>
                <li>
                  This system drives approximately 35% of Amazon's total sales
                  through cross-selling and up-selling
                </li>
              </ul>
            </div>

            <div class="application-card">
              <h4>
                <i class="fas fa-chart-line"></i> Amazon Marketplace
                Intelligence
              </h4>
              <p>
                Third-party sellers benefit from PageRank-inspired seller
                rankings and market analysis:
              </p>
              <ul>
                <li>
                  <strong>Seller Authority Ranking:</strong> Applying PageRank
                  principles to establish seller credibility scores
                </li>
                <li>
                  <strong>Category Authority Detection:</strong> Identifying
                  category specialists vs. general merchants
                </li>
                <li>
                  <strong>Review Network Analysis:</strong> Using graph
                  algorithms to detect fake review networks
                </li>
                <li>
                  Helps maintain marketplace integrity across 9.7 million
                  third-party sellers worldwide
                </li>
              </ul>
            </div>

            <div class="relationship-diagram">
              <h4>Amazon's Product Ranking Ecosystem</h4>
              <div class="diagram-container">
                <img
                  src="https://i.imgur.com/jLHW7a4.png"
                  alt="Amazon's Product Ranking System"
                  style="max-width: 100%; height: auto"
                />
              </div>
            </div>

            <div class="efficiency-metrics">
              <h4>Business Impact at Amazon</h4>
              <div class="metrics-grid">
                <div class="metric-card">
                  <h5>Search Relevance</h5>
                  <div class="metric-value">+41%</div>
                  <p class="metric-description">
                    Improvement in click-through rate on search results
                  </p>
                </div>
                <div class="metric-card">
                  <h5>Recommendation Revenue</h5>
                  <div class="metric-value">$28B</div>
                  <p class="metric-description">
                    Annual revenue directly attributed to recommendations
                  </p>
                </div>
                <div class="metric-card">
                  <h5>Catalog Coverage</h5>
                  <div class="metric-value">99.7%</div>
                  <p class="metric-description">
                    Percentage of active catalog analyzed daily by crawlers
                  </p>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>
    <!---------------------- Case Study: PageRank and Web Crawling ----------------------------- -->

    <!---------------------- Case Study: Product Recommendations ----------------------------- -->

    <section class="algorithm-case-study">
      <div class="container">
        <div class="case-study-header">
          <p class="case-study-subtitle">Algorithm Analysis</p>
          <h2 class="case-study-title">4. Product Recommendations</h2>
          <p class="case-study-intro">
            Exploring how Amazon leverages Best First Search algorithms, A*
            variants, and efficient heap data structures to power its
            personalized recommendation systems, delivering tailored product
            suggestions that drive customer engagement and increase revenue
            across billions of interactions daily.
          </p>
        </div>

        <div class="algorithm-grid">
          <div class="algorithm-explanation">
            <h3>
              Understanding Best First Search and Heaps in Recommendations
            </h3>
            <p>
              Amazon's recommendation systems face a computational challenge:
              finding the most relevant products from a catalog of over 350
              million items in milliseconds. Best First Search algorithms and
              efficient heap implementations allow Amazon to intelligently
              navigate this vast product space, prioritizing the most promising
              recommendations without exhaustively evaluating every possibility.
            </p>

            <div class="algorithm-comparison">
              <div class="algorithm-card">
                <h4>Best First Search & A* Algorithm</h4>
                <p>
                  Best First Search is a search algorithm that explores a graph
                  by expanding the most promising node according to a specified
                  evaluation function. A* extends this by combining actual cost
                  and estimated cost to goal.
                </p>
                <ul>
                  <li>
                    Uses an evaluation function f(n) = g(n) + h(n) to prioritize
                    nodes
                  </li>
                  <li>
                    g(n): Known cost from start to current node (purchase
                    history relevance)
                  </li>
                  <li>
                    h(n): Heuristic estimate to goal (predicted customer
                    interest)
                  </li>
                  <li>
                    Efficiently finds optimal recommendations without exhaustive
                    search
                  </li>
                </ul>
              </div>

              <div class="algorithm-card">
                <h4>Heap Data Structures</h4>
                <p>
                  Heaps provide efficient priority queue operations, crucial for
                  maintaining and retrieving the highest-priority product
                  recommendations in real-time.
                </p>
                <ul>
                  <li>
                    O(log n) insertion and extraction of highest-priority items
                  </li>
                  <li>
                    Binary, Fibonacci, and d-ary heaps used for different
                    scenarios
                  </li>
                  <li>Supports dynamic updates as user behavior changes</li>
                  <li>
                    Enables efficient k-nearest neighbor searches for similar
                    products
                  </li>
                </ul>
              </div>
            </div>

            <div class="algorithm-steps">
              <h4>Key Steps of Amazon's Recommendation Algorithm:</h4>
              <ol>
                <li>
                  Build a personalized customer profile from behavior data:
                  <ul>
                    <li>
                      Purchase history, browsing patterns, and explicit ratings
                    </li>
                    <li>Category preferences and price sensitivity metrics</li>
                    <li>Temporal patterns (recent vs. historical behavior)</li>
                  </ul>
                </li>
                <li>
                  Define similarity and relevance heuristics:
                  <ul>
                    <li>Collaborative filtering signals (similar customers)</li>
                    <li>Content-based signals (product attributes)</li>
                    <li>Context-aware signals (time, device, location)</li>
                  </ul>
                </li>
                <li>
                  Execute Best First Search using a priority queue (heap):
                  <ul>
                    <li>
                      Initialize heap with seed products based on current
                      context
                    </li>
                    <li>
                      Iteratively extract highest-scoring product from the heap
                    </li>
                    <li>Expand to related products, computing f(n) for each</li>
                    <li>
                      Add promising candidates back to the heap with their
                      scores
                    </li>
                  </ul>
                </li>
                <li>
                  Apply diversity and business constraints:
                  <ul>
                    <li>Ensure category diversity in final recommendations</li>
                    <li>Balance novelty with relevance for discovery</li>
                    <li>
                      Consider inventory, margins, and other business factors
                    </li>
                  </ul>
                </li>
                <li>Present top-k recommendations to the customer</li>
              </ol>
            </div>

            <div class="code-snippet">
              <pre><code><span class="comment">// C++ implementation of Amazon-style recommendation system using Best First Search and heaps</span>
<span class="keyword">#include</span> <span class="string">&lt;iostream&gt;</span>
<span class="keyword">#include</span> <span class="string">&lt;vector&gt;</span>
<span class="keyword">#include</span> <span class="string">&lt;queue&gt;</span>
<span class="keyword">#include</span> <span class="string">&lt;unordered_map&gt;</span>
<span class="keyword">#include</span> <span class="string">&lt;unordered_set&gt;</span>
<span class="keyword">#include</span> <span class="string">&lt;algorithm&gt;</span>

<span class="keyword">class</span> <span class="function">ProductRecommender</span> {
<span class="keyword">private</span>:
    <span class="keyword">struct</span> Product {
        <span class="keyword">int</span> id;
        <span class="keyword">std::string</span> category;
        <span class="keyword">double</span> price;
        <span class="keyword">double</span> rating;
        <span class="keyword">int</span> salesRank;
        <span class="keyword">std</span>::vector&lt;<span class="keyword">int</span>&gt; relatedProducts;
    };
    
    <span class="keyword">struct</span> CustomerProfile {
        <span class="keyword">int</span> id;
        <span class="keyword">std</span>::unordered_map&lt;<span class="keyword">std</span>::string, <span class="keyword">double</span>&gt; categoryPreferences;
        <span class="keyword">std</span>::vector&lt;<span class="keyword">int</span>&gt; purchaseHistory;
        <span class="keyword">std</span>::vector&lt;<span class="keyword">int</span>&gt; viewHistory;
        <span class="keyword">double</span> averagePurchasePrice;
    };
    
    <span class="keyword">struct</span> RecommendationCandidate {
        <span class="keyword">int</span> productId;
        <span class="keyword">double</span> gScore;  <span class="comment">// Known relevance based on history</span>
        <span class="keyword">double</span> hScore;  <span class="comment">// Estimated future interest</span>
        <span class="keyword">double</span> fScore;  <span class="comment">// Combined score (g + h)</span>
        <span class="keyword">bool</span> <span class="function">operator<</span>(<span class="keyword">const</span> RecommendationCandidate& other) <span class="keyword">const</span> {
            <span class="keyword">return</span> fScore < other.fScore;  <span class="comment">// For max-heap (highest priority first)</span>
        }
    };
    
    <span class="keyword">std</span>::unordered_map&lt;<span class="keyword">int</span>, Product&gt; productCatalog;
    <span class="keyword">std</span>::unordered_map&lt;<span class="keyword">int</span>, CustomerProfile&gt; customerProfiles;
    
    <span class="comment">// Collaborative filtering model (simplified)</span>
    <span class="keyword">std</span>::unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">std</span>::unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">double</span>&gt;&gt; productSimilarities;
    
    <span class="comment">// Cache for computed recommendations</span>
    <span class="keyword">std</span>::unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">std</span>::vector&lt;<span class="keyword">int</span>&gt;&gt; recommendationCache;
    
    <span class="comment">// Calculate known relevance (g score) based on customer history</span>
    <span class="keyword">double</span> <span class="function">calculateGScore</span>(<span class="keyword">int</span> customerId, <span class="keyword">int</span> productId) {
        <span class="keyword">const</span> CustomerProfile& profile = customerProfiles[customerId];
        <span class="keyword">const</span> Product& product = productCatalog[productId];
        
        <span class="keyword">double</span> score = 0.0;
        
        <span class="comment">// Category preference match</span>
        <span class="keyword">if</span> (profile.categoryPreferences.find(product.category) != profile.categoryPreferences.end()) {
            score += profile.categoryPreferences.at(product.category) * 0.4;
        }
        
        <span class="comment">// Price match (closer to average purchase price = higher score)</span>
        <span class="keyword">double</span> priceDiff = std::abs(product.price - profile.averagePurchasePrice);
        <span class="keyword">double</span> priceMatch = std::max(0.0, 1.0 - priceDiff / profile.averagePurchasePrice);
        score += priceMatch * 0.2;
        
        <span class="comment">// Rating influence</span>
        score += (product.rating / 5.0) * 0.3;
        
        <span class="comment">// Sales rank influence (normalized)</span>
        score += (1.0 / (1.0 + product.salesRank * 0.001)) * 0.1;
        
        <span class="keyword">return</span> score;
    }
    
    <span class="comment">// Calculate heuristic (h score) based on predicted future interest</span>
    <span class="keyword">double</span> <span class="function">calculateHScore</span>(<span class="keyword">int</span> customerId, <span class="keyword">int</span> productId) {
        <span class="keyword">const</span> CustomerProfile& profile = customerProfiles[customerId];
        <span class="keyword">double</span> score = 0.0;
        
        <span class="comment">// Collaborative filtering signal</span>
        <span class="keyword">for</span> (<span class="keyword">int</span> purchasedProduct : profile.purchaseHistory) {
            <span class="keyword">if</span> (productSimilarities[purchasedProduct].find(productId) != 
                productSimilarities[purchasedProduct].end()) {
                score += productSimilarities[purchasedProduct][productId] * 0.6;
            }
        }
        
        <span class="comment">// Recency boost for products related to recently viewed items</span>
        <span class="keyword">if</span> (!profile.viewHistory.empty()) {
            <span class="keyword">for</span> (<span class="keyword">int</span> i = 0; i < std::min(5, (<span class="keyword">int</span>)profile.viewHistory.size()); i++) {
                <span class="keyword">int</span> recentViewedProduct = profile.viewHistory[profile.viewHistory.size() - 1 - i];
                <span class="keyword">if</span> (productSimilarities[recentViewedProduct].find(productId) != 
                    productSimilarities[recentViewedProduct].end()) {
                    <span class="comment">// Higher weight for more recently viewed products</span>
                    <span class="keyword">double</span> recencyWeight = 0.4 * (1.0 - i * 0.1);
                    score += productSimilarities[recentViewedProduct][productId] * recencyWeight;
                }
            }
        }
        
        <span class="keyword">return</span> score;
    }

<span class="keyword">public</span>:
    <span class="comment">// Constructor and initialization methods omitted for brevity</span>
    
    <span class="comment">// Generate personalized recommendations using Best First Search</span>
    <span class="keyword">std</span>::vector&lt;<span class="keyword">int</span>&gt; <span class="function">getRecommendations</span>(<span class="keyword">int</span> customerId, <span class="keyword">int</span> k = 10, <span class="keyword">bool</span> useCache = <span class="keyword">true</span>) {
        <span class="comment">// Check cache first if enabled</span>
        <span class="keyword">if</span> (useCache && recommendationCache.find(customerId) != recommendationCache.end()) {
            <span class="keyword">return</span> recommendationCache[customerId];
        }
        
        <span class="comment">// Ensure customer exists</span>
        <span class="keyword">if</span> (customerProfiles.find(customerId) == customerProfiles.end()) {
            <span class="keyword">return</span> {};
        }
        
        <span class="keyword">const</span> CustomerProfile& profile = customerProfiles[customerId];
        
        <span class="comment">// Max heap priority queue for Best First Search</span>
        <span class="keyword">std</span>::priority_queue&lt;RecommendationCandidate&gt; pq;
        
        <span class="comment">// Track visited products to avoid duplicates</span>
        <span class="keyword">std</span>::unordered_set&lt;<span class="keyword">int</span>&gt; visited;
        
        <span class="comment">// Track products in final recommendation list</span>
        <span class="keyword">std</span>::unordered_set&lt;<span class="keyword">int</span>&gt; recommended;
        
        <span class="comment">// Track category diversity</span>
        <span class="keyword">std</span>::unordered_map&lt;<span class="keyword">std</span>::string, <span class="keyword">int</span>&gt; categoryCount;
        
        <span class="comment">// Seed the search with recent view history or purchase history</span>
        <span class="keyword">std</span>::vector&lt;<span class="keyword">int</span>&gt; seedProducts;
        <span class="keyword">if</span> (!profile.viewHistory.empty()) {
            <span class="comment">// Use last 3 viewed products as seeds</span>
            <span class="keyword">for</span> (<span class="keyword">int</span> i = 0; i < std::min(3, (<span class="keyword">int</span>)profile.viewHistory.size()); i++) {
                seedProducts.push_back(profile.viewHistory[profile.viewHistory.size() - 1 - i]);
            }
        } <span class="keyword">else if</span> (!profile.purchaseHistory.empty()) {
            <span class="comment">// Use last 3 purchased products as seeds</span>
            <span class="keyword">for</span> (<span class="keyword">int</span> i = 0; i < std::min(3, (<span class="keyword">int</span>)profile.purchaseHistory.size()); i++) {
                seedProducts.push_back(profile.purchaseHistory[profile.purchaseHistory.size() - 1 - i]);
            }
        }
        
        <span class="comment">// Initialize search with seed products and their related products</span>
        <span class="keyword">for</span> (<span class="keyword">int</span> seedProduct : seedProducts) {
            <span class="keyword">if</span> (productCatalog.find(seedProduct) != productCatalog.end()) {
                <span class="keyword">for</span> (<span class="keyword">int</span> relatedProduct : productCatalog[seedProduct].relatedProducts) {
                    <span class="keyword">if</span> (visited.find(relatedProduct) == visited.end() && 
                        <span class="keyword">std</span>::find(profile.purchaseHistory.begin(), 
                                profile.purchaseHistory.end(), 
                                relatedProduct) == profile.purchaseHistory.end()) {
                        
                        <span class="keyword">double</span> gScore = calculateGScore(customerId, relatedProduct);
                        <span class="keyword">double</span> hScore = calculateHScore(customerId, relatedProduct);
                        
                        RecommendationCandidate candidate;
                        candidate.productId = relatedProduct;
                        candidate.gScore = gScore;
                        candidate.hScore = hScore;
                        candidate.fScore = gScore + hScore;
                        
                        pq.push(candidate);
                        visited.insert(relatedProduct);
                    }
                }
            }
        }
        
        <span class="comment">// Best First Search to find top recommendations</span>
        <span class="keyword">std</span>::vector&lt;<span class="keyword">int</span>&gt; recommendations;
        <span class="keyword">const</span> <span class="keyword">int</span> MAX_CATEGORIES_PER_RECOMMENDATION = 3;
        <span class="keyword">const</span> <span class="keyword">int</span> MAX_CANDIDATES_TO_EXPLORE = 100;  <span class="comment">// Limit exploration for performance</span>
        <span class="keyword">int</span> candidatesExplored = 0;
        
        <span class="keyword">while</span> (!pq.empty() && recommendations.size() < k && candidatesExplored < MAX_CANDIDATES_TO_EXPLORE) {
            RecommendationCandidate current = pq.top();
            pq.pop();
            candidatesExplored++;
            
            <span class="keyword">if</span> (recommended.find(current.productId) != recommended.end()) {
                <span class="keyword">continue</span>;  <span class="comment">// Skip if already recommended</span>
            }
            
            <span class="keyword">const</span> Product& product = productCatalog[current.productId];
            
            <span class="comment">// Apply diversity constraints</span>
            <span class="keyword">if</span> (categoryCount[product.category] >= MAX_CATEGORIES_PER_RECOMMENDATION) {
                <span class="keyword">continue</span>;  <span class="comment">// Skip to maintain category diversity</span>
            }
            
            <span class="comment">// Add to recommendations</span>
            recommendations.push_back(current.productId);
            recommended.insert(current.productId);
            categoryCount[product.category]++;
            
            <span class="comment">// Explore related products</span>
            <span class="keyword">for</span> (<span class="keyword">int</span> relatedProduct : product.relatedProducts) {
                <span class="keyword">if</span> (visited.find(relatedProduct) == visited.end() && 
                    recommended.find(relatedProduct) == recommended.end() &&
                    <span class="keyword">std</span>::find(profile.purchaseHistory.begin(), 
                            profile.purchaseHistory.end(), 
                            relatedProduct) == profile.purchaseHistory.end()) {
                    
                    <span class="keyword">double</span> gScore = calculateGScore(customerId, relatedProduct);
                    <span class="keyword">double</span> hScore = calculateHScore(customerId, relatedProduct);
                    
                    RecommendationCandidate candidate;
                    candidate.productId = relatedProduct;
                    candidate.gScore = gScore;
                    candidate.hScore = hScore;
                    candidate.fScore = gScore + hScore;
                    
                    pq.push(candidate);
                    visited.insert(relatedProduct);
                }
            }
        }
        
        <span class="comment">// Update cache</span>
        recommendationCache[customerId] = recommendations;
        
        <span class="keyword">return</span> recommendations;
    }
    
    <span class="comment">// Additional methods for updating similarities, customer profiles, etc.</span>
};</code></pre>
            </div>
          </div>

          <div class="amazon-applications">
            <h3>Applications in Amazon's Ecosystem</h3>

            <div class="application-card">
              <h4>
                <i class="fas fa-home"></i> Personalized Homepage Experience
              </h4>
              <p>
                Amazon's homepage uses Best First Search to create a tailored
                entry point for every customer:
              </p>
              <ul>
                <li>
                  <strong>Interest-Based Navigation:</strong> Dynamically
                  organizing homepage sections based on customer interests
                </li>
                <li>
                  <strong>Time-Sensitive Recommendations:</strong> Adjusting
                  search heuristics based on time of day, day of week, and
                  seasonal patterns
                </li>
                <li>
                  <strong>Multi-Objective Optimization:</strong> Balancing
                  personalization with discovery and promotional objectives
                </li>
                <li>
                  This personalization increases homepage conversion rates by
                  35% compared to non-personalized experiences
                </li>
              </ul>
            </div>

            <div class="application-card">
              <h4>
                <i class="fas fa-cart-plus"></i> "Frequently Bought Together"
              </h4>
              <p>
                Amazon's bundle recommendations leverage modified Best First
                Search with custom heuristics:
              </p>
              <ul>
                <li>
                  <strong>Complementary Product Search:</strong> Using
                  heap-based priority queues to efficiently find product
                  combinations with highest purchase correlation
                </li>
                <li>
                  <strong>Bundle Value Optimization:</strong> Custom heuristics
                  that balance bundle price with individual item relevance
                </li>
                <li>
                  <strong>Inventory-Aware Recommendations:</strong> Dynamically
                  adjusting recommendations based on stock levels
                </li>
                <li>
                  Drives an additional 10-15% in order value through strategic
                  cross-selling of complementary products
                </li>
              </ul>
            </div>

            <div class="application-card">
              <h4>
                <i class="fas fa-envelope-open-text"></i> Email Marketing
                Personalization
              </h4>
              <p>
                Amazon's marketing emails use heap-prioritized recommendations
                to maximize engagement:
              </p>
              <ul>
                <li>
                  <strong>Individual Email Customization:</strong> Each
                  marketing email contains unique product recommendations
                  generated via Best First Search
                </li>
                <li>
                  <strong>Time-Optimized Sending:</strong> A* algorithm with
                  temporal heuristics determines optimal sending time for each
                  customer
                </li>
                <li>
                  <strong>Multi-Slot Optimization:</strong> Efficient heap
                  operations to select distinct product groups for different
                  email sections
                </li>
                <li>
                  Results in 3.2x higher click-through rates and 2.7x higher
                  conversion rates compared to non-personalized emails
                </li>
              </ul>
            </div>

            <div class="application-card">
              <h4><i class="fas fa-mobile-alt"></i> Amazon App Experience</h4>
              <p>
                Amazon's mobile app uses memory-efficient heap implementations
                for on-device recommendations:
              </p>
              <ul>
                <li>
                  <strong>Context-Aware Priority Shifts:</strong> Recommendation
                  heuristics that adjust based on mobile context (location,
                  time, connectivity)
                </li>
                <li>
                  <strong>Incremental Result Loading:</strong> Heap-based
                  prioritization for efficient "infinite scroll" recommendation
                  feeds
                </li>
                <li>
                  <strong>On-Device Caching:</strong> Storing partial
                  computation results for rapid response when network
                  connectivity changes
                </li>
                <li>
                  Mobile conversions increased by 29% after implementing these
                  optimized recommendation algorithms
                </li>
              </ul>
            </div>

            <div class="relationship-diagram">
              <h4>Best First Search in Recommendation Systems</h4>
              <div class="diagram-container">
                <img
                  src="https://i.imgur.com/XpYzjL9.png"
                  alt="Amazon Best First Search Recommendation Flow"
                  style="max-width: 100%; height: auto"
                />
              </div>
            </div>

            <div class="efficiency-metrics">
              <h4>Business Impact at Amazon</h4>
              <div class="metrics-grid">
                <div class="metric-card">
                  <h5>Revenue Influence</h5>
                  <div class="metric-value">35%</div>
                  <p class="metric-description">
                    Percentage of Amazon sales directly attributed to
                    personalized recommendations
                  </p>
                </div>
                <div class="metric-card">
                  <h5>Computational Efficiency</h5>
                  <div class="metric-value">-78%</div>
                  <p class="metric-description">
                    Reduction in processing time compared to exhaustive methods
                  </p>
                </div>
                <div class="metric-card">
                  <h5>Engagement Increase</h5>
                  <div class="metric-value">43%</div>
                  <p class="metric-description">
                    Higher product browsing depth with personalized
                    recommendations
                  </p>
                </div>
              </div>
            </div>

            <div class="advanced-features">
              <h4>Amazon's Advanced Recommendation Optimizations</h4>
              <div class="features-grid">
                <div class="feature">
                  <i class="fas fa-bolt"></i>
                  <h5>Real-time Response</h5>
                  <p>
                    Fibonacci heap implementation allows updates in O(1)
                    amortized time when new user actions occur
                  </p>
                </div>
                <div class="feature">
                  <i class="fas fa-balance-scale"></i>
                  <h5>Balanced Exploration</h5>
                  <p>
                    Epsilon-greedy approach occasionally injects serendipitous
                    recommendations to avoid filter bubbles
                  </p>
                </div>
                <div class="feature">
                  <i class="fas fa-brain"></i>
                  <h5>Learning Heuristics</h5>
                  <p>
                    Heuristic functions continuously improve through machine
                    learning from customer interactions
                  </p>
                </div>
                <div class="feature">
                  <i class="fas fa-tachometer-alt"></i>
                  <h5>Adaptive Beam Width</h5>
                  <p>
                    Dynamically adjusts search breadth based on available
                    compute resources and request urgency
                  </p>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>
    <!---------------------- Case Study: Product Recommendations ----------------------------- -->

    <!---------------------- Case Study: Product Catalog Search using Trees ----------------------------- -->

    <section class="algorithm-case-study">
      <div class="container">
        <div class="case-study-header">
          <p class="case-study-subtitle">Algorithm Analysis</p>
          <h2 class="case-study-title">
            5. Product Catalog Search using Trees
          </h2>
          <p class="case-study-intro">
            Exploring how specialized tree data structures power Amazon's
            product search engine, enabling lightning-fast lookups,
            auto-completion, and faceted navigation across hundreds of millions
            of products with millisecond response times.
          </p>
        </div>

        <div class="algorithm-grid">
          <div class="algorithm-explanation">
            <h3>Understanding Tree-Based Search Algorithms</h3>
            <p>
              Amazon's product catalog contains over 350 million items, with
              customers executing billions of search queries daily. Tree-based
              data structures are fundamental to Amazon's ability to deliver
              relevant results at scale, balancing search speed, memory
              efficiency, and result quality through specialized hierarchical
              organizations.
            </p>

            <div class="algorithm-comparison">
              <div class="algorithm-card">
                <h4>Trie (Prefix Tree)</h4>
                <p>
                  Tries optimize prefix-based operations, making them ideal for
                  Amazon's search auto-completion and predictive search
                  features.
                </p>
                <ul>
                  <li>
                    Time complexity: O(L) for lookups where L = length of search
                    term
                  </li>
                  <li>Excellent for prefix matching and auto-suggestions</li>
                  <li>Supports incremental search as customers type</li>
                  <li>
                    Space-optimized through compressed variants (Radix Tries)
                  </li>
                </ul>
              </div>

              <div class="algorithm-card">
                <h4>B+ Trees</h4>
                <p>
                  B+ Trees provide optimized disk-based indexing for Amazon's
                  catalog database, balancing search performance with storage
                  efficiency.
                </p>
                <ul>
                  <li>
                    Time complexity: O(log<sub>m</sub>n) for lookups where m =
                    branching factor
                  </li>
                  <li>
                    Self-balancing to maintain performance with dynamic data
                  </li>
                  <li>Sequential access optimization for range queries</li>
                  <li>Minimizes disk I/O through optimized page sizing</li>
                </ul>
              </div>
            </div>

            <div class="algorithm-steps">
              <h4>Key Steps of Amazon's Catalog Search Process:</h4>
              <ol>
                <li>
                  Query Analysis and Preprocessing:
                  <ul>
                    <li>Tokenize and normalize search query</li>
                    <li>
                      Identify key terms, brands, attributes, and categories
                    </li>
                    <li>Apply spelling correction using edit-distance tries</li>
                    <li>Expand query with synonyms and related terms</li>
                  </ul>
                </li>
                <li>
                  Multi-Index Tree Traversal:
                  <ul>
                    <li>
                      Parallel search across specialized tree indices (category,
                      brand, attribute)
                    </li>
                    <li>Traverse inverted index trees for text relevance</li>
                    <li>
                      Access B+ tree indices for structured attributes (price,
                      ratings)
                    </li>
                  </ul>
                </li>
                <li>
                  Result Aggregation and Ranking:
                  <ul>
                    <li>Combine results from multiple tree traversals</li>
                    <li>Score based on tree-encoded relevance signals</li>
                    <li>Apply business rules and personalization factors</li>
                  </ul>
                </li>
                <li>
                  Faceted Navigation Generation:
                  <ul>
                    <li>
                      Traverse category trees to identify relevant filters
                    </li>
                    <li>Compute cardinality estimates for each filter value</li>
                    <li>Create navigation hierarchy based on taxonomy trees</li>
                  </ul>
                </li>
              </ol>
            </div>

            <div class="code-snippet">
              <pre><code><span class="comment">// C++ implementation of Amazon-style product search using tries and B+ trees</span>
<span class="keyword">#include</span> <span class="string">&lt;iostream&gt;</span>
<span class="keyword">#include</span> <span class="string">&lt;vector&gt;</span>
<span class="keyword">#include</span> <span class="string">&lt;unordered_map&gt;</span>
<span class="keyword">#include</span> <span class="string">&lt;string&gt;</span>
<span class="keyword">#include</span> <span class="string">&lt;memory&gt;</span>
<span class="keyword">#include</span> <span class="string">&lt;algorithm&gt;</span>

<span class="keyword">class</span> <span class="function">ProductCatalogSearch</span> {
<span class="keyword">private</span>:
    <span class="comment">// Trie node structure for auto-completion</span>
    <span class="keyword">struct</span> TrieNode {
        <span class="keyword">bool</span> isEndOfWord;
        std::unordered_map&lt;<span class="keyword">char</span>, std::shared_ptr&lt;TrieNode&gt;&gt; children;
        std::vector&lt;<span class="keyword">int</span>&gt; productIds;  <span class="comment">// Products associated with this prefix</span>
        <span class="keyword">int</span> searchFrequency;  <span class="comment">// How often this prefix is searched</span>
        
        TrieNode() : isEndOfWord(<span class="keyword">false</span>), searchFrequency(0) {}
    };
    
    <span class="comment">// B+ Tree node structure for range-based searches</span>
    <span class="keyword">struct</span> BPlusTreeNode {
        <span class="keyword">bool</span> isLeaf;
        std::vector&lt;<span class="keyword">double</span>&gt; keys;  <span class="comment">// e.g., price points</span>
        std::vector&lt;std::shared_ptr&lt;BPlusTreeNode&gt;&gt; children;
        std::vector&lt;std::vector&lt;<span class="keyword">int</span>&gt;&gt; productIds;  <span class="comment">// Only in leaf nodes</span>
        std::shared_ptr&lt;BPlusTreeNode&gt; nextLeaf;  <span class="comment">// For efficient range queries</span>
        
        BPlusTreeNode(<span class="keyword">bool</span> leaf) : isLeaf(leaf) {}
    };
    
    <span class="comment">// Category tree node for hierarchical navigation</span>
    <span class="keyword">struct</span> CategoryNode {
        <span class="keyword">int</span> categoryId;
        std::string categoryName;
        std::vector&lt;std::shared_ptr&lt;CategoryNode&gt;&gt; subcategories;
        std::vector&lt;<span class="keyword">int</span>&gt; productIds;
        std::unordered_map&lt;std::string, std::vector&lt;std::string&gt;&gt; attributes;
        
        CategoryNode(<span class="keyword">int</span> id, <span class="keyword">const</span> std::string& name) 
            : categoryId(id), categoryName(name) {}
    };
    
    <span class="comment">// Root nodes for our tree structures</span>
    std::shared_ptr&lt;TrieNode&gt; autoCompleteTrieRoot;
    std::shared_ptr&lt;TrieNode&gt; spellCheckTrieRoot;
    std::shared_ptr&lt;BPlusTreeNode&gt; priceIndexRoot;
    std::shared_ptr&lt;CategoryNode&gt; categoryTreeRoot;
    
    <span class="comment">// Product database</span>
    std::unordered_map&lt;<span class="keyword">int</span>, std::unordered_map&lt;std::string, std::string&gt;&gt; productDatabase;
    
    <span class="comment">// Insert a term into the auto-complete trie</span>
    <span class="keyword">void</span> <span class="function">insertIntoTrie</span>(
            <span class="keyword">const</span> std::string& term, 
            <span class="keyword">int</span> productId,
            std::shared_ptr&lt;TrieNode&gt; root) {
        
        std::shared_ptr&lt;TrieNode&gt; current = root;
        
        <span class="keyword">for</span> (<span class="keyword">char</span> c : term) {
            <span class="comment">// Convert to lowercase for case-insensitive search</span>
            <span class="keyword">char</span> lc = std::tolower(c);
            
            <span class="comment">// Create node if it doesn't exist</span>
            <span class="keyword">if</span> (current->children.find(lc) == current->children.end()) {
                current->children[lc] = std::make_shared&lt;TrieNode&gt;();
            }
            
            current = current->children[lc];
            
            <span class="comment">// Add product to this prefix node</span>
            <span class="keyword">if</span> (std::find(current->productIds.begin(), current->productIds.end(), productId) 
                    == current->productIds.end()) {
                current->productIds.push_back(productId);
            }
        }
        
        <span class="comment">// Mark end of word</span>
        current->isEndOfWord = <span class="keyword">true</span>;
    }
    
    <span class="comment">// Insert a product into the B+ tree by price</span>
    <span class="keyword">void</span> <span class="function">insertIntoBPlusTree</span>(<span class="keyword">double</span> price, <span class="keyword">int</span> productId) {
        <span class="comment">// B+ tree insertion logic
        // 1. Traverse to appropriate leaf node
        // 2. Insert key in sorted order
        // 3. If node overflows, split and propagate up
        // 4. Update parent pointers
        // Implementation omitted for brevity</span>
    }
    
    <span class="comment">// Find products by prefix in trie</span>
    std::vector&lt;<span class="keyword">int</span>&gt; <span class="function">findProductsByPrefix</span>(
            <span class="keyword">const</span> std::string& prefix, 
            std::shared_ptr&lt;TrieNode&gt; root,
            <span class="keyword">int</span> limit = 10) {
        
        std::shared_ptr&lt;TrieNode&gt; current = root;
        
        <span class="comment">// Traverse to prefix node</span>
        <span class="keyword">for</span> (<span class="keyword">char</span> c : prefix) {
            <span class="keyword">char</span> lc = std::tolower(c);
            
            <span class="keyword">if</span> (current->children.find(lc) == current->children.end()) {
                <span class="keyword">return</span> {};  <span class="comment">// Prefix not found</span>
            }
            
            current = current->children[lc];
        }
        
        <span class="comment">// Collect products for this prefix</span>
        std::vector&lt;<span class="keyword">int</span>&gt; result = current->productIds;
        
        <span class="comment">// Update search frequency for this prefix</span>
        current->searchFrequency++;
        
        <span class="comment">// Limit results</span>
        <span class="keyword">if</span> (result.size() > limit) {
            result.resize(limit);
        }
        
        <span class="keyword">return</span> result;
    }
    
    <span class="comment">// Find products in price range using B+ tree</span>
    std::vector&lt;<span class="keyword">int</span>&gt; <span class="function">findProductsByPriceRange</span>(<span class="keyword">double</span> minPrice, <span class="keyword">double</span> maxPrice) {
        std::vector&lt;<span class="keyword">int</span>&gt; result;
        
        <span class="comment">// B+ tree range query logic
        // 1. Find leaf node containing minPrice
        // 2. Collect all products within range
        // 3. Follow leaf node pointers until maxPrice is exceeded
        // Implementation omitted for brevity</span>
        
        <span class="keyword">return</span> result;
    }
    
    <span class="comment">// Find products by category traversal</span>
    std::vector&lt;<span class="keyword">int</span>&gt; <span class="function">findProductsByCategory</span>(<span class="keyword">int</span> categoryId) {
        <span class="comment">// Find category node by ID</span>
        <span class="comment">// Recursively collect products from this category and all subcategories</span>
        <span class="comment">// Implementation omitted for brevity</span>
        <span class="keyword">return</span> std::vector&lt;<span class="keyword">int</span>&gt;();
    }
    
    <span class="comment">// Generate spell check suggestions using edit distance in trie</span>
    std::vector&lt;std::string&gt; <span class="function">generateSpellingSuggestions</span>(<span class="keyword">const</span> std::string& query) {
        <span class="comment">// Trie-based spelling correction
        // 1. Find nodes within edit distance threshold
        // 2. Return complete words from those nodes
        // 3. Sort by frequency and edit distance
        // Implementation omitted for brevity</span>
        <span class="keyword">return</span> std::vector&lt;std::string&gt;();
    }

<span class="keyword">public</span>:
    ProductCatalogSearch() {
        <span class="comment">// Initialize tree roots</span>
        autoCompleteTrieRoot = std::make_shared&lt;TrieNode&gt;();
        spellCheckTrieRoot = std::make_shared&lt;TrieNode&gt;();
        priceIndexRoot = std::make_shared&lt;BPlusTreeNode&gt;(<span class="keyword">true</span>);
        categoryTreeRoot = std::make_shared&lt;CategoryNode&gt;(0, "Root");
    }
    
    <span class="comment">// Add a product to all indices</span>
    <span class="keyword">void</span> <span class="function">indexProduct</span>(<span class="keyword">int</span> productId, <span class="keyword">const</span> std::unordered_map&lt;std::string, std::string&gt;& attributes) {
        <span class="comment">// Store in database</span>
        productDatabase[productId] = attributes;
        
        <span class="comment">// Add to tries for title, brand, etc.</span>
        <span class="keyword">if</span> (attributes.find("title") != attributes.end()) {
            insertIntoTrie(attributes.at("title"), productId, autoCompleteTrieRoot);
            insertIntoTrie(attributes.at("title"), productId, spellCheckTrieRoot);
        }
        
        <span class="keyword">if</span> (attributes.find("brand") != attributes.end()) {
            insertIntoTrie(attributes.at("brand"), productId, autoCompleteTrieRoot);
        }
        
        <span class="comment">// Add to B+ tree by price</span>
        <span class="keyword">if</span> (attributes.find("price") != attributes.end()) {
            <span class="keyword">try</span> {
                <span class="keyword">double</span> price = std::stod(attributes.at("price"));
                insertIntoBPlusTree(price, productId);
            } <span class="keyword">catch</span> (...) {
                <span class="comment">// Handle price conversion error</span>
            }
        }
        
        <span class="comment">// Add to category tree</span>
        <span class="keyword">if</span> (attributes.find("category_id") != attributes.end()) {
            <span class="keyword">try</span> {
                <span class="keyword">int</span> categoryId = std::stoi(attributes.at("category_id"));
                <span class="comment">// Logic to insert into proper category tree location</span>
                <span class="comment">// Implementation omitted for brevity</span>
            } <span class="keyword">catch</span> (...) {
                <span class="comment">// Handle category ID conversion error</span>
            }
        }
    }
    
    <span class="comment">// Comprehensive product search function</span>
    <span class="keyword">struct</span> SearchResult {
        std::vector&lt;<span class="keyword">int</span>&gt; productIds;
        std::vector&lt;std::string&gt; spellingSuggestions;
        std::unordered_map&lt;std::string, std::vector&lt;std::string&gt;&gt; facets;
    };
    
    SearchResult <span class="function">search</span>(<span class="keyword">const</span> std::string& query, 
                         <span class="keyword">double</span> minPrice = 0.0, 
                         <span class="keyword">double</span> maxPrice = std::numeric_limits&lt;<span class="keyword">double</span>&gt;::max(),
                         <span class="keyword">int</span> categoryId = -1) {
        
        SearchResult result;
        
        <span class="comment">// 1. Get products matching text query from trie</span>
        std::vector&lt;<span class="keyword">int</span>&gt; textMatchProducts = findProductsByPrefix(query, autoCompleteTrieRoot, 1000);
        
        <span class="comment">// 2. Get products in price range from B+ tree</span>
        std::vector&lt;<span class="keyword">int</span>&gt; priceRangeProducts = findProductsByPriceRange(minPrice, maxPrice);
        
        <span class="comment">// 3. Get products in category from category tree</span>
        std::vector&lt;<span class="keyword">int</span>&gt; categoryProducts;
        <span class="keyword">if</span> (categoryId >= 0) {
            categoryProducts = findProductsByCategory(categoryId);
        }
        
        <span class="comment">// 4. Intersect results from different tree structures</span>
        <span class="comment">// This is a simplified approach; in practice, Amazon uses more sophisticated ranking</span>
        std::unordered_set&lt;<span class="keyword">int</span>&gt; productSet;
        
        <span class="keyword">if</span> (!query.empty()) {
            productSet.insert(textMatchProducts.begin(), textMatchProducts.end());
        }
        
        <span class="keyword">if</span> (minPrice > 0 || maxPrice < std::numeric_limits&lt;<span class="keyword">double</span>&gt;::max()) {
            <span class="keyword">if</span> (productSet.empty()) {
                productSet.insert(priceRangeProducts.begin(), priceRangeProducts.end());
            } <span class="keyword">else</span> {
                <span class="comment">// Filter existing results by price</span>
                std::unordered_set&lt;<span class="keyword">int</span>&gt; priceSet(priceRangeProducts.begin(), priceRangeProducts.end());
                <span class="keyword">for</span> (<span class="keyword">auto</span> it = productSet.begin(); it != productSet.end();) {
                    <span class="keyword">if</span> (priceSet.find(*it) == priceSet.end()) {
                        it = productSet.erase(it);
                    } <span class="keyword">else</span> {
                        ++it;
                    }
                }
            }
        }
        
        <span class="keyword">if</span> (categoryId >= 0) {
            <span class="keyword">if</span> (productSet.empty()) {
                productSet.insert(categoryProducts.begin(), categoryProducts.end());
            } <span class="keyword">else</span> {
                <span class="comment">// Filter existing results by category</span>
                std::unordered_set&lt;<span class="keyword">int</span>&gt; categorySet(categoryProducts.begin(), categoryProducts.end());
                <span class="keyword">for</span> (<span class="keyword">auto</span> it = productSet.begin(); it != productSet.end();) {
                    <span class="keyword">if</span> (categorySet.find(*it) == categorySet.end()) {
                        it = productSet.erase(it);
                    } <span class="keyword">else</span> {
                        ++it;
                    }
                }
            }
        }
        
        <span class="comment">// 5. Generate spell check suggestions if results are sparse</span>
        <span class="keyword">if</span> (productSet.size() < 5 && !query.empty()) {
            result.spellingSuggestions = generateSpellingSuggestions(query);
        }
        
        <span class="comment">// 6. Convert set to vector for final results</span>
        result.productIds.insert(result.productIds.end(), productSet.begin(), productSet.end());
        
        <span class="comment">// 7. Generate facets for navigation (simplified)</span>
        <span class="comment">// In practice, Amazon computes facets based on the result set</span>
        <span class="comment">// Implementation omitted for brevity</span>
        
        <span class="keyword">return</span> result;
    }
    
    <span class="comment">// Autocomplete suggestions based on prefix</span>
    std::vector&lt;std::string&gt; <span class="function">getAutocompleteSuggestions</span>(<span class="keyword">const</span> std::string& prefix, <span class="keyword">int</span> limit = 10) {
        <span class="comment">// Find products matching the prefix</span>
        std::vector&lt;<span class="keyword">int</span>&gt; matchingProducts = findProductsByPrefix(prefix, autoCompleteTrieRoot, 100);
        
        <span class="comment">// Extract and rank suggestions</span>
        std::unordered_map&lt;std::string, <span class="keyword">int</span>&gt; suggestions;
        
        <span class="keyword">for</span> (<span class="keyword">int</span> productId : matchingProducts) {
            <span class="keyword">if</span> (productDatabase.find(productId) != productDatabase.end() && 
                productDatabase[productId].find("title") != productDatabase[productId].end()) {
                
                std::string title = productDatabase[productId]["title"];
                suggestions[title]++;
            }
        }
        
        <span class="comment">// Convert to vector for sorting</span>
        std::vector&lt;std::pair&lt;std::string, <span class="keyword">int</span>&gt;&gt; suggestionPairs;
        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>& pair : suggestions) {
            suggestionPairs.push_back(pair);
        }
        
        <span class="comment">// Sort by frequency</span>
        std::sort(suggestionPairs.begin(), suggestionPairs.end(), 
                 [](<span class="keyword">const</span> std::pair&lt;std::string, <span class="keyword">int</span>&gt;& a, <span class="keyword">const</span> std::pair&lt;std::string, <span class="keyword">int</span>&gt;& b) {
                     <span class="keyword">return</span> a.second > b.second;
                 });
        
        <span class="comment">// Extract top suggestions</span>
        std::vector&lt;std::string&gt; result;
        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = 0; i < suggestionPairs.size() && i < limit; i++) {
            result.push_back(suggestionPairs[i].first);
        }
        
        <span class="keyword">return</span> result;
    }
};</code></pre>
            </div>
          </div>

          <div class="amazon-applications">
            <h3>Applications in Amazon's Ecosystem</h3>

            <div class="application-card">
              <h4>
                <i class="fas fa-search"></i> Real-Time Search Auto-Completion
              </h4>
              <p>
                Amazon's lightning-fast search suggestions rely on optimized
                trie structures to predict user intent:
              </p>
              <ul>
                <li>
                  <strong>Predictive Prefix Matching:</strong> Using compressed
                  tries to suggest products as customers type
                </li>
                <li>
                  <strong>Personalized Completion:</strong> Customer-specific
                  tries that prioritize suggestions based on browsing history
                </li>
                <li>
                  <strong>Multi-Language Support:</strong> Specialized trie
                  implementations handling international character sets and
                  spelling variations
                </li>
                <li>
                  Processes over 5.2 billion auto-completion requests daily with
                  average response time under 20ms
                </li>
              </ul>
            </div>

            <div class="application-card">
              <h4>
                <i class="fas fa-project-diagram"></i> Hierarchical Category
                Navigation
              </h4>
              <p>
                Amazon's extensive product taxonomy is powered by specialized
                tree structures:
              </p>
              <ul>
                <li>
                  <strong>Dynamic Category Trees:</strong> Self-organizing
                  hierarchies that adapt to changing product catalogs and
                  shopping patterns
                </li>
                <li>
                  <strong>Attribute-Aware Navigation:</strong> Tree traversal
                  algorithms that generate relevant facets based on query
                  context
                </li>
                <li>
                  <strong>Multi-Path Categorization:</strong> Graph-enhanced
                  trees allowing products to appear in multiple relevant
                  categories
                </li>
                <li>
                  Enables intuitive navigation across more than 36,000 product
                  categories with consistent sub-50ms response times
                </li>
              </ul>
            </div>

            <div class="application-card">
              <h4>
                <i class="fas fa-spell-check"></i> Intelligent Spell Correction
              </h4>
              <p>
                Amazon's forgiving search experience relies on trie-based
                spelling correction:
              </p>
              <ul>
                <li>
                  <strong>Edit Distance Tries:</strong> Specialized structures
                  that efficiently find terms within specified edit distances
                </li>
                <li>
                  <strong>Phonetic Correction:</strong> Soundex-enhanced tries
                  that identify phonetically similar terms
                </li>
                <li>
                  <strong>Context-Aware Correction:</strong> Domain-specific
                  spelling correction prioritizing product names, brands, and
                  categories
                </li>
                <li>
                  Recovers approximately 15% of potential failed searches
                  through intelligent correction, representing $2.8B in annual
                  recovered revenue
                </li>
              </ul>
            </div>

            <div class="application-card">
              <h4><i class="fas fa-filter"></i> Multi-Dimensional Filtering</h4>
              <p>
                Amazon's powerful filtering system uses specialized tree indices
                for fast constraint application:
              </p>
              <ul>
                <li>
                  <strong>B+ Tree Range Filters:</strong> Efficient filtering on
                  numerical attributes like price, ratings, and dimensions
                </li>
                <li>
                  <strong>Bitmap-Enhanced Indices:</strong> Tree structures
                  augmented with bitmap indices for rapid application of
                  multiple constraints
                </li>
                <li>
                  <strong>Dynamic Facet Generation:</strong> Tree traversal
                  algorithms that identify the most relevant filters for any
                  result set
                </li>
                <li>
                  Handles over 8.3 billion filter operations daily while
                  maintaining sub-100ms response times
                </li>
              </ul>
            </div>

            <div class="relationship-diagram">
              <h4>Tree-Based Search Architecture at Amazon</h4>
              <div class="diagram-container">
                <img
                  src="https://i.imgur.com/EdCkKxY.png"
                  alt="Amazon Tree-Based Search Architecture"
                  style="max-width: 100%; height: auto"
                />
              </div>
            </div>

            <div class="efficiency-metrics">
              <h4>Business Impact at Amazon</h4>
              <div class="metrics-grid">
                <div class="metric-card">
                  <h5>Search Latency</h5>
                  <div class="metric-value">23ms</div>
                  <p class="metric-description">
                    Average response time for catalog search queries using
                    tree-based indexing
                  </p>
                </div>
                <div class="metric-card">
                  <h5>Conversion Lift</h5>
                  <div class="metric-value">+32%</div>
                  <p class="metric-description">
                    Increase in conversion rate from intelligent auto-completion
                    and spelling correction
                  </p>
                </div>
                <div class="metric-card">
                  <h5>Catalog Coverage</h5>
                  <div class="metric-value">99.98%</div>
                  <p class="metric-description">
                    Percentage of active catalog searchable within milliseconds
                    using tree indices
                  </p>
                </div>
              </div>
            </div>

            <div class="advanced-features">
              <h4>Advanced Tree-Based Search Optimizations</h4>
              <div class="features-grid">
                <div class="feature">
                  <i class="fas fa-server"></i>
                  <h5>Distributed Tree Sharding</h5>
                  <p>
                    Partitioning massive tree structures across server clusters
                    based on prefix or category hierarchies
                  </p>
                </div>
                <div class="feature">
                  <i class="fas fa-memory"></i>
                  <h5>Cache-Conscious Trees</h5>
                  <p>
                    Specialized node layouts optimized for CPU cache
                    performance, reducing memory access latency by 47%
                  </p>
                </div>
                <div class="feature">
                  <i class="fas fa-database"></i>
                  <h5>Persistent B+ Trees</h5>
                  <p>
                    Disk-optimized tree structures with incremental updates to
                    maintain performance during catalog changes
                  </p>
                </div>
                <div class="feature">
                  <i class="fas fa-bolt"></i>
                  <h5>Predictive Prefetching</h5>
                  <p>
                    Algorithm that anticipates tree traversal paths and preloads
                    nodes before they're needed
                  </p>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>
    <!---------------------- Case Study: Product Catalog Search using Trees ----------------------------- -->

    <!---------------------- Case Study: Dependency Resolution using Topological Sort ----------------------------- -->

    <section class="algorithm-case-study">
      <div class="container">
        <div class="case-study-header">
          <p class="case-study-subtitle">Algorithm Analysis</p>
          <h2 class="case-study-title">
            6. Dependency Resolution using Topological Sort
          </h2>
          <p class="case-study-intro">
            Exploring how Amazon leverages topological sorting algorithms to
            manage complex dependencies across its microservices architecture,
            supply chain operations, and software deployment systems, enabling
            reliable execution of interdependent processes at unprecedented
            scale.
          </p>
        </div>

        <div class="algorithm-grid">
          <div class="algorithm-explanation">
            <h3>Understanding Topological Sort for Dependency Resolution</h3>
            <p>
              Topological sorting is a fundamental algorithm for ordering the
              vertices of a directed acyclic graph (DAG) such that for every
              directed edge u→v, vertex u comes before v in the ordering. This
              makes it the perfect algorithm for solving dependency resolution
              problems, where certain tasks must be completed before others can
              begin.
            </p>
            <p>
              At Amazon's scale, with millions of interdependent services,
              products, and operations, efficiently resolving dependencies is
              critical for maintaining system reliability and operational
              efficiency.
            </p>

            <div class="algorithm-comparison">
              <div class="algorithm-card">
                <h4>Kahn's Algorithm</h4>
                <p>
                  Kahn's algorithm uses a breadth-first approach to topological
                  sorting, incrementally removing nodes with no incoming edges.
                </p>
                <ul>
                  <li>
                    Time complexity: O(V + E) where V = vertices, E = edges
                  </li>
                  <li>
                    Space complexity: O(V) for storing the queue and in-degree
                    counts
                  </li>
                  <li>Detects cycles (if topological sort is impossible)</li>
                  <li>
                    Iterative implementation ideal for large-scale systems
                  </li>
                </ul>
              </div>

              <div class="algorithm-card">
                <h4>DFS-Based Topological Sort</h4>
                <p>
                  This approach uses depth-first search to build the topological
                  ordering in reverse, adding vertices to the result after all
                  their dependencies have been processed.
                </p>
                <ul>
                  <li>Time complexity: O(V + E)</li>
                  <li>
                    Space complexity: O(V) for recursion stack and visited
                    tracking
                  </li>
                  <li>Can detect cycles with additional tracking</li>
                  <li>Often simpler to implement for recursive dependencies</li>
                </ul>
              </div>
            </div>

            <div class="algorithm-steps">
              <h4>
                Key Steps of Dependency Resolution using Kahn's Algorithm:
              </h4>
              <ol>
                <li>
                  Represent dependencies as a directed graph:
                  <ul>
                    <li>Each task/component is a vertex</li>
                    <li>Each dependency is a directed edge</li>
                    <li>
                      If A depends on B, add edge B→A (B must complete before A)
                    </li>
                  </ul>
                </li>
                <li>
                  Calculate in-degree for each vertex (number of dependencies):
                  <ul>
                    <li>Initialize in-degree counter for each vertex</li>
                    <li>
                      For each edge in the graph, increment the in-degree of the
                      destination vertex
                    </li>
                  </ul>
                </li>
                <li>
                  Identify starting points:
                  <ul>
                    <li>
                      Find all vertices with in-degree of 0 (no dependencies)
                    </li>
                    <li>Add these vertices to a queue</li>
                  </ul>
                </li>
                <li>
                  Process the dependency graph:
                  <ul>
                    <li>While the queue is not empty, remove a vertex</li>
                    <li>Add the removed vertex to the result list</li>
                    <li>
                      For each neighbor of the removed vertex, decrement its
                      in-degree
                    </li>
                    <li>
                      If any neighbor's in-degree becomes 0, add it to the queue
                    </li>
                  </ul>
                </li>
                <li>
                  Verify the resolution:
                  <ul>
                    <li>
                      If the result list contains all vertices, a valid
                      topological ordering was found
                    </li>
                    <li>
                      Otherwise, the graph contains a cycle (circular
                      dependency)
                    </li>
                  </ul>
                </li>
              </ol>
            </div>

            <div class="code-snippet">
              <pre><code><span class="comment">// C++ implementation of dependency resolution using topological sort</span>
<span class="keyword">#include</span> <span class="string">&lt;iostream&gt;</span>
<span class="keyword">#include</span> <span class="string">&lt;vector&gt;</span>
<span class="keyword">#include</span> <span class="string">&lt;queue&gt;</span>
<span class="keyword">#include</span> <span class="string">&lt;unordered_map&gt;</span>
<span class="keyword">#include</span> <span class="string">&lt;string&gt;</span>

<span class="keyword">class</span> <span class="function">DependencyResolver</span> {
<span class="keyword">private</span>:
    <span class="comment">// Graph representation</span>
    std::unordered_map&lt;std::string, std::vector&lt;std::string&gt;&gt; adjacencyList;
    std::unordered_map&lt;std::string, <span class="keyword">int</span>&gt; inDegree;
    std::vector&lt;std::string&gt; services;

<span class="keyword">public</span>:
    <span class="comment">// Add a service to the dependency graph</span>
    <span class="keyword">void</span> <span class="function">addService</span>(<span class="keyword">const</span> std::string& serviceName) {
        <span class="keyword">if</span> (adjacencyList.find(serviceName) == adjacencyList.end()) {
            adjacencyList[serviceName] = std::vector&lt;std::string&gt;();
            inDegree[serviceName] = 0;
            services.push_back(serviceName);
        }
    }

    <span class="comment">// Add a dependency between services (dependent depends on dependency)</span>
    <span class="keyword">void</span> <span class="function">addDependency</span>(<span class="keyword">const</span> std::string& dependency, <span class="keyword">const</span> std::string& dependent) {
        <span class="comment">// Ensure both services exist</span>
        addService(dependency);
        addService(dependent);
        
        <span class="comment">// Add the edge dependency -> dependent</span>
        adjacencyList[dependency].push_back(dependent);
        
        <span class="comment">// Increment in-degree of the dependent service</span>
        inDegree[dependent]++;
    }

    <span class="comment">// Resolve dependencies using Kahn's topological sort algorithm</span>
    std::pair&lt;std::vector&lt;std::string&gt;, <span class="keyword">bool</span>&gt; <span class="function">resolveDependencies</span>() {
        std::vector&lt;std::string&gt; result;
        std::queue&lt;std::string&gt; zeroInDegree;
        
        <span class="comment">// Find all services with no dependencies (in-degree = 0)</span>
        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>& service : services) {
            <span class="keyword">if</span> (inDegree[service] == 0) {
                zeroInDegree.push(service);
            }
        }
        
        <span class="comment">// Process the services</span>
        <span class="keyword">while</span> (!zeroInDegree.empty()) {
            <span class="comment">// Get the next service with no dependencies</span>
            std::string current = zeroInDegree.front();
            zeroInDegree.pop();
            
            <span class="comment">// Add to result order</span>
            result.push_back(current);
            
            <span class="comment">// Process all services that depend on the current service</span>
            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>& dependent : adjacencyList[current]) {
                <span class="comment">// Decrement in-degree of dependent services</span>
                inDegree[dependent]--;
                
                <span class="comment">// If all dependencies are satisfied, add to queue</span>
                <span class="keyword">if</span> (inDegree[dependent] == 0) {
                    zeroInDegree.push(dependent);
                }
            }
        }
        
        <span class="comment">// Check if all services were included in the result</span>
        <span class="keyword">bool</span> isValidResolution = (result.size() == services.size());
        
        <span class="keyword">return</span> {result, isValidResolution};
    }
    
    <span class="comment">// Find and report circular dependencies</span>
    std::vector&lt;std::string&gt; <span class="function">findCircularDependencies</span>() {
        std::vector&lt;std::string&gt; circularDependencies;
        std::unordered_map&lt;std::string, <span class="keyword">bool</span>&gt; visited;
        std::unordered_map&lt;std::string, <span class="keyword">bool</span>&gt; inStack;
        
        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>& service : services) {
            <span class="keyword">if</span> (!visited[service]) {
                detectCycle(service, visited, inStack, circularDependencies);
            }
        }
        
        <span class="keyword">return</span> circularDependencies;
    }
    
<span class="keyword">private</span>:
    <span class="keyword">bool</span> <span class="function">detectCycle</span>(<span class="keyword">const</span> std::string& service, 
                        std::unordered_map&lt;std::string, <span class="keyword">bool</span>&gt;& visited,
                        std::unordered_map&lt;std::string, <span class="keyword">bool</span>&gt;& inStack,
                        std::vector&lt;std::string&gt;& circularDependencies) {
        
        visited[service] = <span class="keyword">true</span>;
        inStack[service] = <span class="keyword">true</span>;
        
        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>& dependent : adjacencyList[service]) {
            <span class="keyword">if</span> (!visited[dependent]) {
                <span class="keyword">if</span> (detectCycle(dependent, visited, inStack, circularDependencies)) {
                    <span class="keyword">if</span> (std::find(circularDependencies.begin(), circularDependencies.end(), service) == circularDependencies.end()) {
                        circularDependencies.push_back(service);
                    }
                    <span class="keyword">return</span> <span class="keyword">true</span>;
                }
            } <span class="keyword">else if</span> (inStack[dependent]) {
                <span class="comment">// Cycle detected</span>
                <span class="keyword">if</span> (std::find(circularDependencies.begin(), circularDependencies.end(), service) == circularDependencies.end()) {
                    circularDependencies.push_back(service);
                }
                <span class="keyword">return</span> <span class="keyword">true</span>;
            }
        }
        
        inStack[service] = <span class="keyword">false</span>;
        <span class="keyword">return</span> <span class="keyword">false</span>;
    }
};</code></pre>
            </div>
          </div>

          <div class="amazon-applications">
            <h3>Applications in Amazon's Ecosystem</h3>

            <div class="application-card">
              <h4>
                <i class="fas fa-network-wired"></i> Microservices Orchestration
              </h4>
              <p>
                Amazon's distributed architecture relies on topological sorting
                to manage service dependencies:
              </p>
              <ul>
                <li>
                  <strong>Service Startup Sequencing:</strong> Determining the
                  correct order to initialize interdependent microservices
                  during deployment or recovery
                </li>
                <li>
                  <strong>Circuit Breaking:</strong> Identifying dependency
                  chains to implement intelligent failure isolation strategies
                </li>
                <li>
                  <strong>Resource Allocation:</strong> Prioritizing critical
                  path services during resource contention scenarios
                </li>
                <li>
                  Managing over 5,000 interdependent microservices with 99.999%
                  availability across AWS infrastructure
                </li>
              </ul>
            </div>

            <div class="application-card">
              <h4><i class="fas fa-cube"></i> AWS CloudFormation</h4>
              <p>
                Amazon's infrastructure-as-code service uses topological sorting
                to manage resource dependencies:
              </p>
              <ul>
                <li>
                  <strong>Resource Provisioning Order:</strong> Determining the
                  correct sequence for creating AWS resources based on their
                  dependencies
                </li>
                <li>
                  <strong>Parallel Deployment:</strong> Identifying independent
                  resource groups that can be provisioned simultaneously
                </li>
                <li>
                  <strong>Deletion Sequence:</strong> Computing the reverse
                  topological order for safe resource deletion
                </li>
                <li>
                  <strong>Dependency Validation:</strong> Detecting circular
                  dependencies in customer templates before deployment
                </li>
                <li>
                  Enables reliable deployment of complex infrastructure stacks
                  with thousands of interdependent resources
                </li>
              </ul>
            </div>

            <div class="application-card">
              <h4><i class="fas fa-boxes"></i> Supply Chain Orchestration</h4>
              <p>
                Amazon's fulfillment network leverages topological sorting for
                complex logistics operations:
              </p>
              <ul>
                <li>
                  <strong>Manufacturing Dependencies:</strong> Sequencing the
                  production and assembly of Amazon devices (Echo, Kindle, etc.)
                </li>
                <li>
                  <strong>Multi-Stage Fulfillment:</strong> Optimizing the flow
                  of products through consolidation centers, fulfillment
                  centers, and delivery stations
                </li>
                <li>
                  <strong>Just-in-Time Inventory:</strong> Scheduling component
                  arrivals based on assembly dependencies
                </li>
                <li>
                  <strong>Critical Path Analysis:</strong> Identifying
                  bottlenecks in the supply chain that could affect delivery
                  promises
                </li>
                <li>
                  Manages dependencies across over 175 fulfillment centers and
                  40+ countries with 18.5 million unique products
                </li>
              </ul>
            </div>

            <div class="application-card">
              <h4><i class="fas fa-code-branch"></i> Software Build System</h4>
              <p>
                Amazon's internal build systems use topological sorting to
                optimize continuous integration/deployment:
              </p>
              <ul>
                <li>
                  <strong>Build Dependency Resolution:</strong> Determining the
                  correct order to compile libraries and applications based on
                  their dependencies
                </li>
                <li>
                  <strong>Parallel Build Scheduling:</strong> Maximizing build
                  parallelism by identifying independent components
                </li>
                <li>
                  <strong>Incremental Build Optimization:</strong> Identifying
                  the minimal set of components that need rebuilding after a
                  change
                </li>
                <li>
                  <strong>Dependency Health Monitoring:</strong> Detecting
                  problematic dependency patterns before they cause build issues
                </li>
                <li>
                  Processes over 1 million code deployments annually with
                  average build times reduced by 68% through intelligent
                  dependency management
                </li>
              </ul>
            </div>

            <div class="relationship-diagram">
              <h4>Dependency Resolution Architecture</h4>
              <div class="diagram-container">
                <img
                  src="https://i.imgur.com/qXUcVPe.png"
                  alt="Amazon Dependency Resolution Architecture"
                  style="max-width: 100%; height: auto"
                />
              </div>
            </div>

            <div class="efficiency-metrics">
              <h4>Business Impact at Amazon</h4>
              <div class="metrics-grid">
                <div class="metric-card">
                  <h5>Deployment Success</h5>
                  <div class="metric-value">99.7%</div>
                  <p class="metric-description">
                    First-time success rate for complex service deployments
                    using topological ordering
                  </p>
                </div>
                <div class="metric-card">
                  <h5>System Recovery</h5>
                  <div class="metric-value">-73%</div>
                  <p class="metric-description">
                    Reduction in recovery time during outages through optimized
                    service restart sequencing
                  </p>
                </div>
                <div class="metric-card">
                  <h5>Build Optimization</h5>
                  <div class="metric-value">9.4x</div>
                  <p class="metric-description">
                    Increase in build parallelism through intelligent dependency
                    analysis
                  </p>
                </div>
              </div>
            </div>

            <div class="advanced-features">
              <h4>Advanced Dependency Resolution Techniques</h4>
              <div class="features-grid">
                <div class="feature">
                  <i class="fas fa-sitemap"></i>
                  <h5>Layered Dependency Analysis</h5>
                  <p>
                    Grouping services into logical layers to simplify dependency
                    management and increase system resilience
                  </p>
                </div>
                <div class="feature">
                  <i class="fas fa-project-diagram"></i>
                  <h5>Dynamic Dependency Injection</h5>
                  <p>
                    Runtime resolution of service dependencies based on system
                    health, load, and availability zones
                  </p>
                </div>
                <div class="feature">
                  <i class="fas fa-exclamation-triangle"></i>
                  <h5>Circular Dependency Detection</h5>
                  <p>
                    Proactive identification and refactoring of problematic
                    circular dependencies before they cause production issues
                  </p>
                </div>
                <div class="feature">
                  <i class="fas fa-clock"></i>
                  <h5>Temporal Dependency Resolution</h5>
                  <p>
                    Incorporating time-based constraints when resolving
                    dependencies for time-sensitive operations
                  </p>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!---------------------- Case Study: Dependency Resolution using Topological Sort ----------------------------- -->


    <!---------------------- Case Study: Managing Customer Traffic ----------------------------- -->
    <section class="algorithm-case-study">
      <div class="container">
        <div class="case-study-header">
          <p class="case-study-subtitle">Algorithm Analysis</p>
          <h2 class="case-study-title">6. Managing Customer Traffic with Ford-Fulkerson</h2>
          <p class="case-study-intro">
            Exploring how Amazon leverages network flow algorithms like Ford-Fulkerson to optimize customer traffic distribution 
            across its digital platforms, physical facilities, and service systems, ensuring optimal resource utilization while 
            maintaining exceptional customer experience even during peak demand periods.
          </p>
        </div>

        <div class="algorithm-grid">
          <div class="algorithm-explanation">
            <h3>Understanding Network Flow Algorithms</h3>
            <p>
              Amazon handles billions of customer interactions daily across its websites, mobile apps, fulfillment centers, 
              and customer service channels. Network flow algorithms provide the mathematical foundation for intelligently 
              distributing this massive traffic load, treating the flow of customers, orders, and requests as a network 
              optimization problem.
            </p>

            <div class="algorithm-comparison">
              <div class="algorithm-card">
                <h4>Ford-Fulkerson Algorithm</h4>
                <p>
                  The Ford-Fulkerson algorithm finds the maximum flow in a flow network by iteratively identifying augmenting paths 
                  and increasing flow until no more paths exist.
                </p>
                <ul>
                  <li>Time complexity: O(E × max_flow) where E = edges in the network</li>
                  <li>Uses residual graphs to track remaining capacity</li>
                  <li>Guarantees optimal flow distribution</li>
                  <li>Highly adaptable to different capacity constraints</li>
                </ul>
              </div>

              <div class="algorithm-card">
                <h4>Edmonds-Karp Variant</h4>
                <p>
                  The Edmonds-Karp algorithm implements Ford-Fulkerson using breadth-first search to find the shortest augmenting 
                  path, improving efficiency for Amazon's large-scale systems.
                </p>
                <ul>
                  <li>Time complexity: O(V × E²) where V = vertices, E = edges</li>
                  <li>Always selects the shortest augmenting path</li>
                  <li>More predictable runtime for large networks</li>
                  <li>Better suited for dynamic capacity adjustments</li>
                </ul>
              </div>
            </div>

            <div class="algorithm-steps">
              <h4>Key Steps of the Ford-Fulkerson Algorithm in Amazon's Systems:</h4>
              <ol>
                <li>Model the traffic network:
                  <ul>
                    <li>Define sources (customer entry points) and sinks (service endpoints)</li>
                    <li>Map intermediate nodes (servers, fulfillment centers, etc.)</li>
                    <li>Establish capacity constraints for each channel</li>
                    <li>Create a directed graph with edge capacities representing maximum traffic flow</li>
                  </ul>
                </li>
                <li>Initialize flow values:
                  <ul>
                    <li>Set initial flow to zero for all edges</li>
                    <li>Create a residual graph tracking remaining capacity</li>
                  </ul>
                </li>
                <li>Iteratively augment flow:
                  <ul>
                    <li>Find an augmenting path from source to sink with available capacity</li>
                    <li>Identify the bottleneck capacity along the path</li>
                    <li>Increase flow along the path by the bottleneck value</li>
                    <li>Update residual capacities in both directions</li>
                  </ul>
                </li>
                <li>Dynamic rebalancing:
                  <ul>
                    <li>Monitor actual traffic patterns in real-time</li>
                    <li>Adjust capacity constraints based on system performance</li>
                    <li>Recalculate optimal flow when conditions change</li>
                  </ul>
                </li>
                <li>Handle overflow conditions:
                  <ul>
                    <li>Implement graceful degradation strategies when demand exceeds total capacity</li>
                    <li>Apply priority rules for critical traffic</li>
                    <li>Dynamically provision additional resources when possible</li>
                  </ul>
                </li>
              </ol>
            </div>

            <div class="code-snippet">
              <pre><code><span class="comment">// C++ implementation of Ford-Fulkerson algorithm for Amazon's traffic management</span>
    <span class="keyword">#include</span> <span class="string">&lt;iostream&gt;</span>
    <span class="keyword">#include</span> <span class="string">&lt;vector&gt;</span>
    <span class="keyword">#include</span> <span class="string">&lt;queue&gt;</span>
    <span class="keyword">#include</span> <span class="string">&lt;limits&gt;</span>
    <span class="keyword">#include</span> <span class="string">&lt;string&gt;</span>
    <span class="keyword">#include</span> <span class="string">&lt;unordered_map&gt;</span>

    <span class="keyword">class</span> <span class="function">TrafficFlowManager</span> {
    <span class="keyword">private</span>:
        <span class="keyword">struct</span> Node {
            std::string id;
            std::string type;  <span class="comment">// "entry", "server", "service", "fulfillment", etc.</span>
            <span class="keyword">int</span> currentLoad;
            <span class="keyword">int</span> maxCapacity;
            
            Node(std::string _id, std::string _type, <span class="keyword">int</span> _maxCapacity) 
                : id(_id), type(_type), currentLoad(0), maxCapacity(_maxCapacity) {}
        };
        
        <span class="keyword">int</span> numNodes;
        std::vector&lt;Node&gt; nodes;
        std::vector&lt;std::vector&lt;<span class="keyword">int</span>&gt;&gt; capacity;  <span class="comment">// Capacity matrix</span>
        std::vector&lt;std::vector&lt;<span class="keyword">int</span>&gt;&gt; flow;      <span class="comment">// Flow matrix</span>
        
        <span class="comment">// Map node IDs to indices</span>
        std::unordered_map&lt;std::string, <span class="keyword">int</span>&gt; nodeIndex;
        
        <span class="comment">// Source and sink indices</span>
        <span class="keyword">int</span> source;
        <span class="keyword">int</span> sink;

    <span class="keyword">public</span>:
        TrafficFlowManager() : numNodes(0), source(-1), sink(-1) {}
        
        <span class="comment">// Add a node to the network</span>
        <span class="keyword">void</span> <span class="function">addNode</span>(<span class="keyword">const</span> std::string& id, <span class="keyword">const</span> std::string& type, <span class="keyword">int</span> maxCapacity) {
            nodeIndex[id] = numNodes;
            nodes.push_back(Node(id, type, maxCapacity));
            
            <span class="comment">// Resize matrices to include new node</span>
            capacity.resize(numNodes + 1, std::vector&lt;<span class="keyword">int</span>&gt;(numNodes + 1, 0));
            flow.resize(numNodes + 1, std::vector&lt;<span class="keyword">int</span>&gt;(numNodes + 1, 0));
            
            <span class="keyword">for</span> (<span class="keyword">int</span> i = 0; i < numNodes; i++) {
                capacity[i].resize(numNodes + 1, 0);
                flow[i].resize(numNodes + 1, 0);
            }
            
            numNodes++;
            
            <span class="comment">// Set source and sink if appropriate</span>
            <span class="keyword">if</span> (type == "entry" && source == -1) {
                source = numNodes - 1;
            }
            <span class="keyword">if</span> (type == "service" && sink == -1) {
                sink = numNodes - 1;
            }
        }
        
        <span class="comment">// Add a connection between nodes with a given capacity</span>
        <span class="keyword">void</span> <span class="function">addConnection</span>(<span class="keyword">const</span> std::string& fromId, <span class="keyword">const</span> std::string& toId, <span class="keyword">int</span> connectionCapacity) {
            <span class="keyword">int</span> u = nodeIndex[fromId];
            <span class="keyword">int</span> v = nodeIndex[toId];
            capacity[u][v] = connectionCapacity;
        }
        
        <span class="comment">// Set custom source and sink nodes</span>
        <span class="keyword">void</span> <span class="function">setSourceAndSink</span>(<span class="keyword">const</span> std::string& sourceId, <span class="keyword">const</span> std::string& sinkId) {
            source = nodeIndex[sourceId];
            sink = nodeIndex[sinkId];
        }
        
        <span class="comment">// BFS to find an augmenting path (Edmonds-Karp implementation)</span>
        <span class="keyword">bool</span> <span class="function">bfs</span>(std::vector&lt;<span class="keyword">int</span>&gt;& parent) {
            std::vector&lt;<span class="keyword">bool</span>&gt; visited(numNodes, <span class="keyword">false</span>);
            std::queue&lt;<span class="keyword">int</span>&gt; q;
            
            q.push(source);
            visited[source] = <span class="keyword">true</span>;
            parent[source] = -1;
            
            <span class="keyword">while</span> (!q.empty()) {
                <span class="keyword">int</span> u = q.front();
                q.pop();
                
                <span class="keyword">for</span> (<span class="keyword">int</span> v = 0; v < numNodes; v++) {
                    <span class="comment">// If there's remaining capacity and not visited</span>
                    <span class="keyword">if</span> (!visited[v] && capacity[u][v] > flow[u][v]) {
                        q.push(v);
                        parent[v] = u;
                        visited[v] = <span class="keyword">true</span>;
                    }
                }
            }
            
            <span class="comment">// If we reached sink in BFS</span>
            <span class="keyword">return</span> visited[sink];
        }
        
        <span class="comment">// Ford-Fulkerson algorithm with Edmonds-Karp path finding</span>
        <span class="keyword">int</span> <span class="function">computeMaximumFlow</span>() {
            <span class="keyword">if</span> (source == -1 || sink == -1) {
                std::cerr << "Source or sink not defined" << std::endl;
                <span class="keyword">return</span> -1;
            }
            
            <span class="keyword">int</span> maxFlow = 0;
            std::vector&lt;<span class="keyword">int</span>&gt; parent(numNodes);
            
            <span class="comment">// Augment flow while there is a path from source to sink</span>
            <span class="keyword">while</span> (bfs(parent)) {
                <span class="comment">// Find the maximum flow through the augmenting path</span>
                <span class="keyword">int</span> pathFlow = std::numeric_limits&lt;<span class="keyword">int</span>&gt;::max();
                
                <span class="comment">// Find bottleneck capacity</span>
                <span class="keyword">for</span> (<span class="keyword">int</span> v = sink; v != source; v = parent[v]) {
                    <span class="keyword">int</span> u = parent[v];
                    pathFlow = std::min(pathFlow, capacity[u][v] - flow[u][v]);
                }
                
                <span class="comment">// Update residual capacities and reverse edges</span>
                <span class="keyword">for</span> (<span class="keyword">int</span> v = sink; v != source; v = parent[v]) {
                    <span class="keyword">int</span> u = parent[v];
                    flow[u][v] += pathFlow;
                    flow[v][u] -= pathFlow;  <span class="comment">// For residual graph</span>
                }
                
                maxFlow += pathFlow;
            }
            
            <span class="keyword">return</span> maxFlow;
        }
        
        <span class="comment">// Get current flow distribution</span>
        std::vector&lt;std::pair&lt;std::string, std::string&gt;&gt; <span class="function">getCurrentFlowDistribution</span>() {
            std::vector&lt;std::pair&lt;std::string, std::string&gt;&gt; flowDistribution;
            
            <span class="keyword">for</span> (<span class="keyword">int</span> u = 0; u < numNodes; u++) {
                <span class="keyword">for</span> (<span class="keyword">int</span> v = 0; v < numNodes; v++) {
                    <span class="keyword">if</span> (flow[u][v] > 0) {
                        flowDistribution.push_back({nodes[u].id, nodes[v].id});
                    }
                }
            }
            
            <span class="keyword">return</span> flowDistribution;
        }
        
        <span class="comment">// Adapt to changing traffic conditions</span>
        <span class="keyword">void</span> <span class="function">updateCapacity</span>(<span class="keyword">const</span> std::string& fromId, <span class="keyword">const</span> std::string& toId, <span class="keyword">int</span> newCapacity) {
            <span class="keyword">int</span> u = nodeIndex[fromId];
            <span class="keyword">int</span> v = nodeIndex[toId];
            capacity[u][v] = newCapacity;
            
            <span class="comment">// Ensure flow doesn't exceed new capacity</span>
            <span class="keyword">if</span> (flow[u][v] > capacity[u][v]) {
                flow[u][v] = capacity[u][v];
            }
        }
        
        <span class="comment">// Simulate traffic distribution during peak load</span>
        <span class="keyword">void</span> <span class="function">simulatePeakTraffic</span>(<span class="keyword">int</span> expectedTraffic) {
            <span class="keyword">int</span> maxCapacity = computeMaximumFlow();
            
            std::cout << "Maximum traffic capacity: " << maxCapacity << std::endl;
            std::cout << "Expected peak traffic: " << expectedTraffic << std::endl;
            
            <span class="keyword">if</span> (expectedTraffic > maxCapacity) {
                std::cout << "Warning: Expected traffic exceeds capacity by " 
                          << (expectedTraffic - maxCapacity) << " units" << std::endl;
                
                <span class="comment">// Implement overflow handling strategies</span>
                <span class="comment">// ...</span>
            } <span class="keyword">else</span> {
                std::cout << "Network can handle expected traffic" << std::endl;
                
                <span class="comment">// Calculate utilization percentage</span>
                <span class="keyword">double</span> utilization = (<span class="keyword">double</span>)expectedTraffic / maxCapacity * 100.0;
                std::cout << "Utilization: " << utilization << "%" << std::endl;
            }
        }
    };</code></pre>
            </div>
          </div>

          <div class="amazon-applications">
            <h3>Applications in Amazon's Ecosystem</h3>

            <div class="application-card">
              <h4>
                <i class="fas fa-cloud"></i> AWS Traffic Distribution
              </h4>
              <p>
                Amazon Web Services uses network flow algorithms to optimize global traffic distribution across its massive infrastructure:
              </p>
              <ul>
                <li>
                  <strong>Dynamic Load Balancing:</strong> Ford-Fulkerson variants determine optimal traffic distribution across availability zones and regions
                </li>
                <li>
                  <strong>DDoS Protection:</strong> Network flow analysis identifies and mitigates abnormal traffic patterns in real-time
                </li>
                <li>
                  <strong>Capacity Planning:</strong> Maximum flow calculations predict when to scale infrastructure before demand exceeds capacity
                </li>
                <li>
                  <strong>Results:</strong> Maintains 99.999% uptime for critical services while optimizing resource utilization, saving approximately $420M annually in infrastructure costs
                </li>
              </ul>
            </div>

            <div class="application-card">
              <h4>
                <i class="fas fa-shopping-cart"></i> E-Commerce Traffic Management
              </h4>
              <p>
                Amazon's global website and app infrastructure leverages flow algorithms to handle massive traffic spikes:
              </p>
              <ul>
                <li>
                  <strong>Prime Day Scaling:</strong> Flow algorithms distribute traffic across server pools during peak events when traffic increases by up to 1,000%
                </li>
                <li>
                  <strong>Service Prioritization:</strong> Critical paths (checkout, payment) receive protected capacity during high-volume periods
                </li>
                <li>
                  <strong>Geographic Distribution:</strong> Customer traffic is optimally routed to the nearest available data center with sufficient capacity
                </li>
                <li>
                  <strong>Results:</strong> Handles over 5.2 billion page requests during peak events with average response times under 200ms, increasing conversion rates by 32% compared to competitors during high-traffic periods
                </li>
              </ul>
            </div>

            <div class="application-card">
              <h4>
                <i class="fas fa-headset"></i> Customer Service Routing
              </h4>
              <p>
                Amazon's customer service system uses Ford-Fulkerson principles to optimally route customer inquiries:
              </p>
              <ul>
                <li>
                  <strong>Skills-Based Routing:</strong> Flow networks model agent capabilities and customer needs as capacity-constrained edges
                </li>
                <li>
                  <strong>Multi-Channel Optimization:</strong> Balances traffic across voice, chat, email, and social media channels based on real-time capacity
                </li>
                <li>
                  <strong>Wait-Time Minimization:</strong> Dynamically adjusts routing to distribute wait times fairly while prioritizing urgent issues
                </li>
                <li>
                  <strong>Results:</strong> Reduces average customer wait time by 42% while improving first-contact resolution rate by 23%, handling over 10 million customer inquiries daily
                </li>
              </ul>
            </div>

            <div class="application-card">
              <h4>
                <i class="fas fa-warehouse"></i> Fulfillment Network Optimization
              </h4>
              <p>
                Amazon's massive logistics network uses flow algorithms to manage order processing capacity:
              </p>
              <ul>
                <li>
                  <strong>Order Routing:</strong> Maximum flow calculations determine optimal distribution of orders across fulfillment centers
                </li>
                <li>
                  <strong>Processing Capacity Management:</strong> Flow networks model inbound shipments, processing stations, and outbound delivery capacity
                </li>
                <li>
                  <strong>Holiday Season Scaling:</strong> Dynamic capacity adjustments during peak seasons maintain service levels despite 4x normal volume
                </li>
                <li>
                  <strong>Results:</strong> Enables Amazon to process over 1.6 million packages per day at a single fulfillment center with 99.8% on-time delivery rate, even during peak periods
                </li>
              </ul>
            </div>

            <div class="relationship-diagram">
              <h4>Network Flow Model of Amazon's Traffic Management</h4>
              <div class="diagram-container">
                <img
                  src="https://i.imgur.com/4jZLdRt.png"
                  alt="Amazon's Traffic Flow Network Model"
                  style="max-width: 100%; height: auto"
                />
              </div>
            </div>

            <div class="efficiency-metrics">
              <h4>Business Impact at Amazon</h4>
              <div class="metrics-grid">
                <div class="metric-card">
                  <h5>Traffic Handling</h5>
                  <div class="metric-value">8.2B</div>
                  <p class="metric-description">
                    Daily web requests processed with optimized flow distribution
                  </p>
                </div>
                <div class="metric-card">
                  <h5>Infrastructure Savings</h5>
                  <div class="metric-value">41%</div>
                  <p class="metric-description">
                    Reduction in server requirements through optimized traffic flow
                  </p>
                </div>
                <div class="metric-card">
                  <h5>Customer Experience</h5>
                  <div class="metric-value">99.7%</div>
                  <p class="metric-description">
                    Customer requests processed without perceptible delay during peak periods
                  </p>
                </div>
              </div>
            </div>

            <div class="advanced-features">
              <h4>Advanced Network Flow Optimizations at Amazon</h4>
              <div class="features-grid">
                <div class="feature">
                  <i class="fas fa-tachometer-alt"></i>
                  <h5>Real-Time Flow Recalculation</h5>
                  <p>
                    Incremental flow updates that adjust to changing traffic patterns without full recalculation
                  </p>
                </div>
                <div class="feature">
                  <i class="fas fa-chart-line"></i>
                  <h5>Predictive Capacity Scaling</h5>
                  <p>
                    ML-enhanced flow models that anticipate traffic spikes before they occur and pre-allocate resources
                  </p>
                </div>
                <div class="feature">
                  <i class="fas fa-balance-scale"></i>
                  <h5>Multi-Objective Optimization</h5>
                  <p>
                    Enhanced algorithms that balance throughput, latency, and cost considerations simultaneously
                  </p>
                </div>
                <div class="feature">
                  <i class="fas fa-project-diagram"></i>
                  <h5>Hierarchical Flow Management</h5>
                  <p>
                    Nested flow networks that optimize at global, regional, and local levels for better scalability
                  </p>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>
    <!---------------------- Case Study: Managing Customer Traffic ----------------------------- -->

    <!---------------------- Case Study: Skip Lists in Search Indexing ----------------------------- -->
<section class="algorithm-case-study">
  <div class="container">
    <div class="case-study-header">
      <p class="case-study-subtitle">Algorithm Analysis</p>
      <h2 class="case-study-title">7. Skip Lists in Search Indexing</h2>
      <p class="case-study-intro">
        Exploring how Amazon leverages Skip Lists to power efficient search indexing across its massive catalog, 
        enabling blazing-fast lookups and range queries while maintaining exceptional flexibility for frequent updates 
        in high-throughput environments.
      </p>
    </div>

    <div class="algorithm-grid">
      <div class="algorithm-explanation">
        <h3>Understanding Skip Lists for Search Indexing</h3>
        <p>
          Skip Lists are probabilistic data structures that provide an elegant alternative to balanced trees, 
          offering similar performance characteristics with simpler implementation and maintenance. At Amazon's scale, 
          these properties make Skip Lists particularly valuable for high-throughput search indexing where millions 
          of updates occur alongside billions of queries daily.
        </p>
        <p>
          The structure combines the simplicity of linked lists with logarithmic search time by maintaining multiple 
          layers of linked lists, with each higher layer "skipping" over elements to accelerate search operations.
        </p>

        <div class="algorithm-comparison">
          <div class="algorithm-card">
            <h4>Skip List Structure</h4>
            <p>
              Skip Lists organize elements in a hierarchy of linked lists, allowing searches to skip unnecessary comparisons 
              by traversing at higher levels first.
            </p>
            <ul>
              <li>Time complexity: O(log n) for search, insert, and delete operations</li>
              <li>Space complexity: O(n) with a constant factor overhead for express lanes</li>
              <li>Probabilistic balancing requires no explicit rebalancing operations</li>
              <li>Natural support for range queries and ordered traversal</li>
            </ul>
          </div>

          <div class="algorithm-card">
            <h4>Advantages for Search Indexing</h4>
            <p>
              Skip Lists offer several key advantages that make them ideal for Amazon's dynamic search infrastructure.
            </p>
            <ul>
              <li>Lock-free concurrent implementations for high-throughput systems</li>
              <li>Minimal memory overhead compared to B-trees in memory-constrained environments</li>
              <li>Excellent performance for range queries commonly used in search filters</li>
              <li>Simple implementation reduces maintenance burden and bug potential</li>
            </ul>
          </div>
        </div>

        <div class="algorithm-steps">
          <h4>Key Steps of Skip List Operations in Amazon's Search Systems:</h4>
          <ol>
            <li>Search Operation:
              <ul>
                <li>Start at the highest level of the skip list from the leftmost node</li>
                <li>Move horizontally as far as possible without overshooting target</li>
                <li>Drop down one level and repeat until reaching the bottom level</li>
                <li>Perform final horizontal scan to locate exact match or insertion point</li>
              </ul>
            </li>
            <li>Insertion Operation:
              <ul>
                <li>Search to find the appropriate position for the new element</li>
                <li>Randomly determine the element's maximum level (height)</li>
                <li>Insert the element at the bottom level and all randomly chosen levels above</li>
                <li>Update relevant pointers to maintain the skip list structure</li>
              </ul>
            </li>
            <li>Range Query Operation:
              <ul>
                <li>Search to locate the starting position of the range</li>
                <li>Traverse horizontally at the bottom level, collecting elements within range</li>
                <li>Continue until reaching the upper bound of the query range</li>
                <li>Apply any additional filters or transformations to the results</li>
              </ul>
            </li>
            <li>Concurrent Access Optimization:
              <ul>
                <li>Implement lock-free or fine-grained locking strategies</li>
                <li>Use atomic operations for node updates to prevent race conditions</li>
                <li>Maintain consistent state during concurrent read/write operations</li>
                <li>Employ optimistic retry mechanisms for contended updates</li>
              </ul>
            </li>
          </ol>
        </div>

        <div class="code-snippet">
          <pre><code><span class="comment">// C++ implementation of a Skip List optimized for search indexing</span>
<span class="keyword">#include</span> <span class="string">&lt;iostream&gt;</span>
<span class="keyword">#include</span> <span class="string">&lt;vector&gt;</span>
<span class="keyword">#include</span> <span class="string">&lt;random&gt;</span>
<span class="keyword">#include</span> <span class="string">&lt;string&gt;</span>
<span class="keyword">#include</span> <span class="string">&lt;memory&gt;</span>
<span class="keyword">#include</span> <span class="string">&lt;limits&gt;</span>

<span class="keyword">class</span> <span class="function">SearchIndexSkipList</span> {
<span class="keyword">private</span>:
    <span class="keyword">struct</span> SkipNode {
        std::string key;           <span class="comment">// Search term or product ID</span>
        std::string value;         <span class="comment">// Document reference or metadata</span>
        <span class="keyword">int</span> score;                <span class="comment">// Relevance score for ranking</span>
        std::vector&lt;SkipNode*&gt; forward;  <span class="comment">// Pointers to nodes at each level</span>
        
        SkipNode(<span class="keyword">const</span> std::string& k, <span class="keyword">const</span> std::string& v, <span class="keyword">int</span> s, <span class="keyword">int</span> level) 
            : key(k), value(v), score(s), forward(level + 1, <span class="keyword">nullptr</span>) {}
    };
    
    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> MAX_LEVEL = 16;  <span class="comment">// Maximum level for skip list</span>
    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">float</span> P = 0.5f;      <span class="comment">// Probability for level promotion</span>
    
    SkipNode* head;    <span class="comment">// Head of the skip list</span>
    <span class="keyword">int</span> currentLevel;  <span class="comment">// Current maximum level in the skip list</span>
    <span class="keyword">int</span> size;          <span class="comment">// Number of elements in the skip list</span>
    
    <span class="comment">// Random level generator with p=0.5 probability</span>
    <span class="keyword">int</span> <span class="function">randomLevel</span>() {
        <span class="keyword">static</span> std::random_device rd;
        <span class="keyword">static</span> std::mt19937 gen(rd());
        <span class="keyword">static</span> std::uniform_real_distribution&lt;<span class="keyword">float</span>&gt; dis(0.0f, 1.0f);
        
        <span class="keyword">int</span> level = 0;
        <span class="keyword">while</span> (dis(gen) < P && level < MAX_LEVEL - 1) {
            level++;
        }
        <span class="keyword">return</span> level;
    }

<span class="keyword">public</span>:
    SearchIndexSkipList() : currentLevel(0), size(0) {
        <span class="comment">// Create head node with maximum level</span>
        head = <span class="keyword">new</span> SkipNode("", "", std::numeric_limits&lt;<span class="keyword">int</span>&gt;::min(), MAX_LEVEL);
    }
    
    ~SearchIndexSkipList() {
        <span class="comment">// Clean up all nodes</span>
        SkipNode* current = head;
        <span class="keyword">while</span> (current) {
            SkipNode* next = current->forward[0];
            <span class="keyword">delete</span> current;
            current = next;
        }
    }
    
    <span class="comment">// Insert a key-value pair with relevance score</span>
    <span class="keyword">void</span> <span class="function">insert</span>(<span class="keyword">const</span> std::string& key, <span class="keyword">const</span> std::string& value, <span class="keyword">int</span> score) {
        std::vector&lt;SkipNode*&gt; update(MAX_LEVEL + 1, <span class="keyword">nullptr</span>);
        SkipNode* current = head;
        
        <span class="comment">// Find the position to insert at each level</span>
        <span class="keyword">for</span> (<span class="keyword">int</span> i = currentLevel; i >= 0; i--) {
            <span class="keyword">while</span> (current->forward[i] && 
                   (current->forward[i]->key < key || 
                    (current->forward[i]->key == key && current->forward[i]->score < score))) {
                current = current->forward[i];
            }
            update[i] = current;
        }
        
        <span class="comment">// Move to the next node at level 0</span>
        current = current->forward[0];
        
        <span class="comment">// If key exists with same score, update value</span>
        <span class="keyword">if</span> (current && current->key == key && current->score == score) {
            current->value = value;
            <span class="keyword">return</span>;
        }
        
        <span class="comment">// Generate random level for new node</span>
        <span class="keyword">int</span> newLevel = randomLevel();
        
        <span class="comment">// Update skip list's level if necessary</span>
        <span class="keyword">if</span> (newLevel > currentLevel) {
            <span class="keyword">for</span> (<span class="keyword">int</span> i = currentLevel + 1; i <= newLevel; i++) {
                update[i] = head;
            }
            currentLevel = newLevel;
        }
        
        <span class="comment">// Create and link the new node</span>
        SkipNode* newNode = <span class="keyword">new</span> SkipNode(key, value, score, newLevel);
        <span class="keyword">for</span> (<span class="keyword">int</span> i = 0; i <= newLevel; i++) {
            newNode->forward[i] = update[i]->forward[i];
            update[i]->forward[i] = newNode;
        }
        
        size++;
    }
    
    <span class="comment">// Search for a specific key</span>
    std::pair&lt;std::string, <span class="keyword">int</span>&gt; <span class="function">search</span>(<span class="keyword">const</span> std::string& key) {
        SkipNode* current = head;
        
        <span class="comment">// Search from top level down</span>
        <span class="keyword">for</span> (<span class="keyword">int</span> i = currentLevel; i >= 0; i--) {
            <span class="keyword">while</span> (current->forward[i] && current->forward[i]->key < key) {
                current = current->forward[i];
            }
        }
        
        <span class="comment">// Move to the potential match</span>
        current = current->forward[0];
        
        <span class="comment">// Check if we found the key</span>
        <span class="keyword">if</span> (current && current->key == key) {
            <span class="keyword">return</span> {current->value, current->score};
        }
        
        <span class="keyword">return</span> {"", -1};  <span class="comment">// Not found</span>
    }
    
    <span class="comment">// Find top k results within a range</span>
    std::vector&lt;std::pair&lt;std::string, <span class="keyword">int</span>&gt;&gt; <span class="function">rangeQuery</span>(
            <span class="keyword">const</span> std::string& startKey, 
            <span class="keyword">const</span> std::string& endKey, 
            <span class="keyword">int</span> topK) {
        
        std::vector&lt;std::pair&lt;std::string, <span class="keyword">int</span>&gt;&gt; results;
        SkipNode* current = head;
        
        <span class="comment">// Find the starting position</span>
        <span class="keyword">for</span> (<span class="keyword">int</span> i = currentLevel; i >= 0; i--) {
            <span class="keyword">while</span> (current->forward[i] && current->forward[i]->key < startKey) {
                current = current->forward[i];
            }
        }
        
        <span class="comment">// Move to the first potential match</span>
        current = current->forward[0];
        
        <span class="comment">// Collect results within range</span>
        <span class="keyword">while</span> (current && current->key <= endKey && results.size() < topK) {
            results.push_back({current->value, current->score});
            current = current->forward[0];
        }
        
        <span class="comment">// Sort by score (descending)</span>
        std::sort(results.begin(), results.end(), 
                 [](<span class="keyword">const</span> std::pair&lt;std::string, <span class="keyword">int</span>&gt;& a, 
                    <span class="keyword">const</span> std::pair&lt;std::string, <span class="keyword">int</span>&gt;& b) {
                     <span class="keyword">return</span> a.second > b.second;
                 });
        
        <span class="keyword">return</span> results;
    }
    
    <span class="comment">// Prefix search implementation (for auto-complete)</span>
    std::vector&lt;std::pair&lt;std::string, <span class="keyword">int</span>&gt;&gt; <span class="function">prefixSearch</span>(<span class="keyword">const</span> std::string& prefix, <span class="keyword">int</span> limit) {
        SkipNode* current = head;
        std::vector&lt;std::pair&lt;std::string, <span class="keyword">int</span>&gt;&gt; results;
        
        <span class="comment">// Find the first key >= prefix</span>
        <span class="keyword">for</span> (<span class="keyword">int</span> i = currentLevel; i >= 0; i--) {
            <span class="keyword">while</span> (current->forward[i] && current->forward[i]->key < prefix) {
                current = current->forward[i];
            }
        }
        
        current = current->forward[0];
        
        <span class="comment">// Collect all keys with the given prefix</span>
        <span class="keyword">while</span> (current && results.size() < limit) {
            <span class="comment">// Check if current key has the prefix</span>
            <span class="keyword">if</span> (current->key.size() >= prefix.size() && 
                current->key.substr(0, prefix.size()) == prefix) {
                results.push_back({current->key, current->score});
            } <span class="keyword">else if</span> (current->key.substr(0, prefix.size()) > prefix) {
                <span class="comment">// We've moved past potential matches</span>
                <span class="keyword">break</span>;
            }
            
            current = current->forward[0];
        }
        
        <span class="comment">// Sort by score (descending)</span>
        std::sort(results.begin(), results.end(), 
                 [](<span class="keyword">const</span> std::pair&lt;std::string, <span class="keyword">int</span>&gt;& a, 
                    <span class="keyword">const</span> std::pair&lt;std::string, <span class="keyword">int</span>&gt;& b) {
                     <span class="keyword">return</span> a.second > b.second;
                 });
        
        <span class="keyword">return</span> results;
    }
    
    <span class="comment">// Get current size of the skip list</span>
    <span class="keyword">int</span> <span class="function">getSize</span>() <span class="keyword">const</span> {
        <span class="keyword">return</span> size;
    }
};</code></pre>
        </div>
      </div>

      <div class="amazon-applications">
        <h3>Applications in Amazon's Ecosystem</h3>

        <div class="application-card">
          <h4>
            <i class="fas fa-search"></i> Amazon Catalog Search Indexing
          </h4>
          <p>
            Amazon's product catalog search utilizes Skip Lists to enable fast lookups and complex filtering:
          </p>
          <ul>
            <li>
              <strong>Partial Keyword Indexing:</strong> Skip Lists maintain sorted lexicographical order of product terms for lightning-fast prefix searches
            </li>
            <li>
              <strong>Real-time Index Updates:</strong> New products and price changes are reflected in search results within seconds through efficient Skip List insertion
            </li>
            <li>
              <strong>Multi-Tier Index Architecture:</strong> Specialized Skip Lists organize products by category, price range, and rating for rapid multi-faceted filtering
            </li>
            <li>
              <strong>High-throughput Updates:</strong> Skip Lists' lock-free implementation supports over 3.2 million product catalog updates per hour with minimal search performance impact
            </li>
          </ul>
        </div>

        <div class="application-card">
          <h4>
            <i class="fas fa-database"></i> DynamoDB Sorted Index Implementation
          </h4>
          <p>
            Amazon's DynamoDB utilizes Skip List structures for its sorted index operations:
          </p>
          <ul>
            <li>
              <strong>Range-Based Partition Keys:</strong> Skip Lists power efficient range scans across partition keys in local secondary indexes
            </li>
            <li>
              <strong>Consistent Performance:</strong> Probabilistic balancing provides predictable O(log n) operations regardless of data distribution
            </li>
            <li>
              <strong>Incremental Scaling:</strong> Skip Lists allow DynamoDB to maintain performance as tables grow from gigabytes to petabytes
            </li>
            <li>
              <strong>Memory Efficiency:</strong> Skip Lists' compact representation reduces memory overhead by 23% compared to equivalent B-tree implementations
            </li>
          </ul>
        </div>

        <div class="application-card">
          <h4>
            <i class="fas fa-clock"></i> Time-Series Data Processing
          </h4>
          <p>
            Amazon's monitoring and IoT systems use Skip Lists for time-series data management:
          </p>
          <ul>
            <li>
              <strong>Time-Ordered Events:</strong> Skip Lists naturally maintain chronological order for time-series data from AWS CloudWatch metrics
            </li>
            <li>
              <strong>Temporal Range Queries:</strong> Efficiently retrieve data from specific time windows with sub-millisecond latency
            </li>
            <li>
              <strong>Hot and Cold Data Management:</strong> Skip Lists facilitate tiered storage strategies where recent data requires frequent access
            </li>
            <li>
              <strong>Real-time Alerting:</strong> Enables monitoring systems to process over 1.8 trillion metric points daily with 99.99% of alerts triggered within 500ms
            </li>
          </ul>
        </div>

        <div class="application-card">
          <h4>
            <i class="fas fa-sort-amount-down"></i> Ranked Retrieval Systems
          </h4>
          <p>
            Amazon's recommendation engines leverage Skip Lists for ranked item retrieval:
          </p>
          <ul>
            <li>
              <strong>Score-Based Ordering:</strong> Skip Lists efficiently maintain items sorted by relevance scores for recommendation systems
            </li>
            <li>
              <strong>Top-K Query Optimization:</strong> Specialized Skip List variants retrieve only the highest-scoring items without scanning entire datasets
            </li>
            <li>
              <strong>Multi-Dimensional Ranking:</strong> Composite Skip Lists combine multiple relevance factors (popularity, personalization, recency) into unified rankings
            </li>
            <li>
              <strong>Incremental Updates:</strong> Recommendation scores can be continually refined without rebuilding entire index structures
            </li>
          </ul>
        </div>

        <div class="relationship-diagram">
          <h4>Skip List Architecture in Amazon's Search Systems</h4>
          <div class="diagram-container">
            <img
              src="https://i.imgur.com/k7F9Zml.png"
              alt="Skip List Architecture in Amazon Search Systems"
              style="max-width: 100%; height: auto"
            />
          </div>
        </div>

        <div class="efficiency-metrics">
          <h4>Business Impact at Amazon</h4>
          <div class="metrics-grid">
            <div class="metric-card">
              <h5>Search Latency</h5>
              <div class="metric-value">-47%</div>
              <p class="metric-description">
                Reduction in p99 latency for range-based catalog searches using Skip List indexes
              </p>
            </div>
            <div class="metric-card">
              <h5>Index Update Speed</h5>
              <div class="metric-value">8.2ms</div>
              <p class="metric-description">
                Average time to update search indexes with new products or price changes
              </p>
            </div>
            <div class="metric-card">
              <h5>Memory Efficiency</h5>
              <div class="metric-value">+31%</div>
              <p class="metric-description">
                Improvement in RAM utilization compared to previous index structures
              </p>
            </div>
          </div>
        </div>

        <div class="advanced-features">
          <h4>Advanced Skip List Optimizations at Amazon</h4>
          <div class="features-grid">
            <div class="feature">
              <i class="fas fa-bolt"></i>
              <h5>Lock-Free Concurrency</h5>
              <p>
                Specialized lock-free Skip List implementation enabling hundreds of thousands of concurrent operations per second
              </p>
            </div>
            <div class="feature">
              <i class="fas fa-compress-arrows-alt"></i>
              <h5>Compressed Skip Lists</h5>
              <p>
                Memory-optimized variants that reduce pointer overhead through run-length encoding of skip pointers
              </p>
            </div>
            <div class="feature">
              <i class="fas fa-layer-group"></i>
              <h5>Level Optimization</h5>
              <p>
                Adaptive level distribution that optimizes skip list height based on actual access patterns
              </p>
            </div>
            <div class="feature">
              <i class="fas fa-database"></i>
              <h5>Persistent Skip Lists</h5>
              <p>
                Disk-backed implementations providing durability while maintaining logarithmic access performance
              </p>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</section>
<!---------------------- Case Study: Skip Lists in Search Indexing ----------------------------- -->




    <script src="./script2.js"></script>
  </body>
</html>
